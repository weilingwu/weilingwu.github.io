
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>front-end study</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Weiling Wu">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="front-end study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="front-end study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiling Wu">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="front-end study" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/katong.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="front-end study" title="front-end study"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="front-end study">front-end study</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/archives">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/03/03/dom/" title="dom" itemprop="url">dom</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-03-03T06:08:16.000Z" itemprop="datePublished"> Published 2022-03-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="dom-文档对象模型"><a href="#dom-文档对象模型" class="headerlink" title="dom(文档对象模型)"></a>dom(文档对象模型)</h1><p><strong>JS中通过DOM来对HTML文档进行操作</strong>，只要理解了DOM就可以随心所欲的操作WEB页面。</p>
<ul>
<li><p>文档：文档表示的就是整个HTML网页文档</p>
</li>
<li><p>对象：对象表示将网页中的每一个部分都转换成了一个对象</p>
</li>
<li><p>模型：使用模型来表示对象之间的关系，这样方便我们获取对象</p>
</li>
</ul>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><ul>
<li><p><strong>节点Node，是构成我们网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点。</strong>比如：html标签、属性、文本、注释、整个文档等都是一个节点。</p>
</li>
<li><p>虽然是节点，但是实际上他们的具体类型是不同的。比如：标签我们成为<strong>元素节点</strong>，属性成为<strong>属性节点</strong>，文本称为<strong>文本节点</strong>，文档成为<strong>文档节点</strong>。节点的类型不同，属性和方法也都不尽相同。</p>
</li>
<li><p>浏览器已经为我们提供了文档节点，这个对象是window属性，可以在页面中直接使用。文档节点代表的是整个网页。<strong>document就是这个文档节点。</strong></p>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><p>事件，就是文档或浏览器窗口中发生的一些特性交互瞬间。</p>
</li>
<li><p><strong>js与HTML之间的交互是通过事件来实现的。</strong></p>
</li>
<li><p>对于Web应用来说，有下面的这些代表性的事件：<strong>点击某个元素</strong>，<strong>将鼠标移动到某个元素上方</strong>，<strong>按下键盘上的某个键</strong>，等等。</p>
<pre><code>  //获取按钮对象
  var btn = document.getElementById(&quot;btn&quot;);
  //可以为按钮的对应事件绑定处理函数的形式来响应事件，这样当事件被触发时，其对应的函数将会被调用。
  btn.onclick = function()&#123;
  alert(&quot;你还点~~&quot;);
  &#125;
</code></pre>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/html5/" title="html5" itemprop="url">html5</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T10:43:25.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="lt-audio-gt"><a href="#lt-audio-gt" class="headerlink" title="&lt;audio&gt;"></a><code>&lt;audio&gt;</code></h1><p>播放声音：</p>
<pre><code>&lt;audio controls&gt;
  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;
  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
  您的浏览器不支持 audio 元素。
&lt;/audio&gt;
</code></pre>
<p><audio> 标签定义声音，比如音乐或其他音频流。<audio> 标签是 HTML5 的新标签。</p>
<table align="center" border="1px" cellspacing="0px" cellpadding="8px" >
    <tr height="20px" align="center" >
        <td width="50px">属性</td>
        <td>值</td>
        <td>描述</td>
    </tr>
    <tr height="20px" align="center">
        <td width="100px">autoplay</td>
        <td>autoplay</td>
        <td>如果出现该属性，则音频在就绪后马上播放。</td>
    </tr>
     <tr height="20px" align="center">
        <td width="100px">controls</td>
        <td>controls</td>
        <td>如果出现该属性，则向用户显示音频控件（比如播放/暂停按钮）。</td>
    </tr>
     <tr height="20px" align="center">
        <td width="100px">loop</td>
        <td>loop</td>
        <td>如果出现该属性，则每当音频结束时重新开始播放。</td>
    </tr>
     <tr height="20px" align="center">
        <td width="100px">mutedNew</td>
        <td>muted</td>
        <td>如果出现该属性，则音频输出为静音。</td>
    </tr>
     <tr height="20px" align="center">
        <td width="100px">preloadNew</td>
        <td>auto、metadata、none</td>
        <td>规定当网页加载时，音频是否默认被加载以及如何被加载。</td>
    </tr>
     <tr height="20px" align="center">
        <td width="100px">metadata</td>
        <td>URL</td>
        <td>规定音频文件的 URL。</td>
    </tr>
</table>

<h1 id="lt-video-gt-类同-lt-audio-gt"><a href="#lt-video-gt-类同-lt-audio-gt" class="headerlink" title="&lt;video&gt;类同&lt;audio&gt;"></a><code>&lt;video&gt;</code>类同<code>&lt;audio&gt;</code></h1><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证：color、date、datetime、datetime-local、email、month、number、range、search、tel、time、url、week。</p>
<p>选择你喜欢的颜色: <code>&lt;input type=&quot;color&quot;&gt;</code></p>
<h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><p>HTML5 <code>&lt;canvas&gt;</code> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成。<code>&lt;canvas&gt;</code> 标签只是图形容器，您必须使用脚本来绘制图形。你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; 
    &lt;meta charset=&quot;utf-8&quot;&gt; 
    &lt;title&gt;study&lt;/title&gt; 
&lt;/head&gt;
&lt;body&gt;

    &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;&lt;/canvas&gt;
    &lt;script&gt;
    
        var c=document.getElementById(&quot;myCanvas&quot;);
        var ctx=c.getContext(&quot;2d&quot;);
        ctx.font=&quot;30px Arial&quot;;
        ctx.strokeText(&quot;Hello World&quot;,10,50);
    
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="表单元素-lt-datalist-gt"><a href="#表单元素-lt-datalist-gt" class="headerlink" title="表单元素&lt;datalist&gt;"></a>表单元素<code>&lt;datalist&gt;</code></h1><p><code>&lt;datalist&gt;</code> 元素规定输入域的选项列表。<code>&lt;datalist&gt;</code> 属性规定 <code>form</code> 或 <code>input</code> 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项：使用 <code>&lt;input&gt;</code> 元素的列表属性与 <code>&lt;datalist&gt;</code> 元素绑定.</p>
<pre><code>&lt;input&quot;&gt;
&lt;datalist&gt;
  &lt;option value=&quot;IE&quot;&gt;
  &lt;option value=&quot;Firefox&quot;&gt;
&lt;/datalist&gt;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/CSS3/" title="CSS3" itemprop="url">CSS3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T08:19:43.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="position-的四个值：static、relative、absolute、fixed"><a href="#position-的四个值：static、relative、absolute、fixed" class="headerlink" title="position 的四个值：static、relative、absolute、fixed"></a>position 的四个值：static、relative、absolute、fixed</h1><ul>
<li><p>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>relative：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</p>
</li>
<li><p>static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
</li>
</ul>
<h1 id="CSS-伪类-Pseudo-classes"><a href="#CSS-伪类-Pseudo-classes" class="headerlink" title="CSS 伪类(Pseudo-classes)"></a>CSS 伪类(Pseudo-classes)</h1><p>CSS伪类是用来添加一些选择器的特殊效果。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>伪类的语法：<code>selector:pseudo-class &#123;property:value;&#125;</code></p>
<p>CSS类也可以使用伪类：<code>selector.class:pseudo-class &#123;property:value;&#125;</code></p>
<h2 id="anchor伪类"><a href="#anchor伪类" class="headerlink" title="anchor伪类"></a>anchor伪类</h2><p>在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示<br>实例：</p>
<pre><code>a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */
a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */
a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */
a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */
</code></pre>
<p>注意： 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p>
<p>注意： 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p>
<p>注意：伪类的名称不区分大小写。</p>
<h2 id="伪类和CSS类"><a href="#伪类和CSS类" class="headerlink" title="伪类和CSS类"></a>伪类和CSS类</h2><p>伪类可以与 CSS 类配合使用：</p>
<pre><code>a.red:visited &#123;color:#FF0000;&#125;
 
&lt;a class=&quot;red&quot; href=&quot;css-syntax.html&quot;&gt;CSS 语法&lt;/a&gt;
</code></pre>
<p>如果在上面的例子的链接已被访问，它会显示为红色。</p>
<h2 id="CSS-first-child-伪类"><a href="#CSS-first-child-伪类" class="headerlink" title="CSS :first-child 伪类"></a>CSS :first-child 伪类</h2><p>您可以使用 :first-child 伪类来选择父元素的第一个子元素。</p>
<p>注意：在IE8的之前版本必须声明&lt;!DOCTYPE&gt; ，这样 :first-child 才能生效。<br>匹配第一个 <code>&lt;p&gt;</code> 元素</p>
<p>在下面的例子中，选择器匹配作为任何元素的第一个子元素的 <code>&lt;p&gt;</code> 元素：</p>
<pre><code>p:first-child
&#123;
    color:blue;
&#125;
</code></pre>
<p>匹配所有<code>&lt;p&gt;</code> 元素中的第一个 <code>&lt;i&gt;</code> 元素</p>
<p>在下面的例子中，选择相匹配的所有<p>元素的第一个 <code>&lt;i&gt;</code> 元素：</p>
<pre><code>p &gt; i:first-child
&#123;
    color:blue;
&#125;
</code></pre>
<p>匹配所有作为第一个子元素的 <p> 元素中的所有 <code>&lt;i&gt;</code> 元素</p>
<p>在下面的例子中，选择器匹配所有作为元素的第一个子元素的 <code>&lt;p&gt;</code> 元素中的所有 <code>&lt;i&gt;</code> 元素：</p>
<pre><code>p:first-child i
&#123;
    color:blue;
&#125;
</code></pre>
<h1 id="CSS-伪元素"><a href="#CSS-伪元素" class="headerlink" title="CSS 伪元素"></a>CSS 伪元素</h1><p>CSS伪元素是用来添加一些选择器的特殊效果。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>伪元素的语法：<code>selector:pseudo-element &#123;property:value;&#125;</code></p>
<p>CSS类也可以使用伪元素：<code>selector.class:pseudo-element &#123;property:value;&#125;</code></p>
<h2 id="first-line-伪元素"><a href="#first-line-伪元素" class="headerlink" title=":first-line 伪元素"></a>:first-line 伪元素</h2><p>“first-line” 伪元素用于向文本的首行设置特殊样式。</p>
<p>在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：</p>
<pre><code>p:first-line 
&#123;
    color:#ff0000;
    font-variant:small-caps;
&#125;
</code></pre>
<p>注意：”first-line” 伪元素只能用于块级元素。</p>
<h2 id="伪元素和CSS类"><a href="#伪元素和CSS类" class="headerlink" title="伪元素和CSS类"></a>伪元素和CSS类</h2><p>伪元素可以结合CSS类： </p>
<pre><code>p.article:first-letter &#123;color:#ff0000;&#125;

&lt;p class=&quot;article&quot;&gt;文章段落&lt;/p&gt;
</code></pre>
<p>上面的例子会使所有 class 为 article 的段落的首字母变为红色。</p>
<p>在下面的例子中，段落的第一个字母将显示为红色，其字体大小为 xx-large。第一行中的其余文本将为蓝色，并以小型大写字母显示。</p>
<p>段落中的其余文本将以默认字体大小和颜色来显示：</p>
<pre><code>p:first-letter
&#123;
    color:#ff0000;
    font-size:xx-large;
&#125;
p:first-line 
&#123;
    color:#0000ff;
    font-variant:small-caps;
&#125;
</code></pre>
<h2 id="CSS-before-伪元素"><a href="#CSS-before-伪元素" class="headerlink" title="CSS - :before 伪元素"></a>CSS - :before 伪元素</h2><p>“:before” 伪元素可以在元素的内容前面插入新内容。</p>
<p>下面的例子在每个 <code>&lt;h1&gt;</code>元素前面插入一幅图片：</p>
<pre><code>h1:before 
&#123;
    content:url(smiley.gif);
&#125;
</code></pre>
<h2 id="CSS-after-伪元素"><a href="#CSS-after-伪元素" class="headerlink" title="CSS - :after 伪元素"></a>CSS - :after 伪元素</h2><p>“:after” 伪元素可以在元素的内容之后插入新内容。</p>
<p>下面的例子在每个 <code>&lt;h1&gt;</code> 元素后面插入一幅图片：</p>
<pre><code>h1:after
&#123;
    content:url(smiley.gif);
&#125;
</code></pre>
<h1 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h1><ul>
<li><p><strong>伪类选择元素基于的是当前元素处于的状态</strong>，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</p>
</li>
<li><p>与伪类针对特殊状态的元素不同的是，<strong>伪元素是对元素中的特定内容进行操作</strong>，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。</p>
</li>
</ul>
<h1 id="弹性盒子-Flex-Box"><a href="#弹性盒子-Flex-Box" class="headerlink" title="弹性盒子(Flex Box)"></a>弹性盒子(Flex Box)</h1><ul>
<li><p>CSS3 弹性盒子（ Flexible Box 或 flexbox），<strong>是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</strong>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>
</li>
<li><p>弹性盒子由<strong>弹性容器</strong>(Flex container)和<strong>弹性子元素</strong>(Flex item)组成。弹性容器通过设置 <strong>display</strong> 属性的值为 flex 或 inline-flex将其定义为弹性容器。弹性容器内包含了一个或多个弹性子元素。</p>
</li>
</ul>
<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><p>实现思路：</p>
<p>一般都是先实现PC端页面，然后再去做其他设备的兼容</p>
<p>设置宽度时，最好不要写死(px)，而是用%单位参照父元素的大小</p>
<p>设置最外层容器时，用vw, vh作单位</p>
<p>不同设备需要换行显示时，使用flex-direction:columns;</p>
<p>导航条一定条件下，显示隐藏</p>
<p>内边距和外边距还有高度可以适当的用px单位</p>
<p>媒体查询时，主要的改变有：换行显示、隐藏，其余都是小改动，比如font-size, margin等等</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/mockjs/" title="mockjs" itemprop="url">mockjs</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T08:01:45.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="为什么使用mockjs"><a href="#为什么使用mockjs" class="headerlink" title="为什么使用mockjs"></a>为什么使用mockjs</h1><p>（原文出自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d812ce349265%EF%BC%89">https://www.jianshu.com/p/d812ce349265）</a></p>
<p>在做开发时，当后端的接口还未完成，前端为了不影响工作效率，手动模拟后端接口，</p>
<pre><code>1.我们可以使用json文件来模拟后台数据，但比较局限，无法模拟数据的增删改查
2.使用json-server模拟，但不能随机生成所需数据
3.使用mockjs模拟后端接口，可随机生成所需数据，可模拟对数据的增删改查
</code></pre>
<h1 id="mock优点"><a href="#mock优点" class="headerlink" title="mock优点"></a>mock优点</h1><pre><code>1.前后端分离，
2.可随机生成大量的数据
3.用法简单
4.数据类型丰富
5.可扩展数据类型
6.在已有接口文档的情况下，我们可以直接按照接口文档来开发，将相应的字段写好，在接口完成 之后，只需要改变url地址即可。
</code></pre>
<h1 id="mock使用"><a href="#mock使用" class="headerlink" title="mock使用"></a>mock使用</h1><pre><code>npm install mockjs --save-dev
// 引入 Mock
var Mock = require(&#39;mockjs&#39;)

// 定义数据类型
var data = Mock.mock(&#123;
  // 20条数据
  &quot;data|20&quot;: [&#123;
    // 商品种类
    &quot;goodsClass&quot;: &quot;女装&quot;,
    // 商品Id
    &quot;goodsId|+1&quot;: 1,
    //商品名称
    &quot;goodsName&quot;: &quot;@ctitle(10)&quot;,
    //商品地址
    &quot;goodsAddress&quot;: &quot;@county(true)&quot;,
    //商品等级评价★
    &quot;goodsStar|1-5&quot;: &quot;★&quot;,
    //商品图片
    &quot;goodsImg&quot;: &quot;@Image(&#39;100x100&#39;,&#39;@color&#39;,&#39;小甜甜&#39;)&quot;,
    //商品售价
    &quot;goodsSale|30-500&quot;: 30

  &#125;]
&#125;)
// 输出结果随机生成的数据（node index.js）
 console.log(data);
</code></pre>
<h1 id="mockjs的数据类型-及-语法规范"><a href="#mockjs的数据类型-及-语法规范" class="headerlink" title="mockjs的数据类型 及 语法规范"></a>mockjs的数据类型 及 语法规范</h1><h2 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h2><p>Mock.Random是一个工具类，用于生成各种随机数据。<br>Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数])</p>
<h2 id="定义数据类型，详情见官方文档"><a href="#定义数据类型，详情见官方文档" class="headerlink" title="定义数据类型，详情见官方文档"></a>定义数据类型，详情见官方文档</h2><pre><code>// 引入 Mock
var Mock = require(&#39;mockjs&#39;)

// 定义数据类型
var data = Mock.mock(&#123;
  // 20条数据
  &quot;data|3&quot;: [&#123;
    // 商品种类
    &quot;goodsClass&quot;: &quot;女装&quot;,
    // 商品Id
    &quot;goodsId|+1&quot;: 1,
    //商品名称
    &quot;goodsName&quot;: &quot;@ctitle(10)&quot;,
    //商品地址
    &quot;goodsAddress&quot;: &quot;@county(true)&quot;,
    //商品等级评价★
    &quot;goodsStar|1-5&quot;: &quot;★&quot;,
    //商品图片
    &quot;goodsImg&quot;: &quot;@Image(&#39;100x100&#39;,&#39;@color&#39;,&#39;小甜甜&#39;)&quot;,
    //商品售价
    &quot;goodsSale|30-500&quot;: 30,

    // 邮箱：
    &quot;email&quot;: &quot;@email&quot;,
    // 颜色
    &quot;color&quot;: &quot;@color&quot;,

    // name
    &quot;name&quot;: &quot;@name&quot;,

    //img,参数1：背景色，参2：前景色，参3：图片的格式，默认png，参4：图片上的文字

    &quot;img&quot;: &quot;@image(&#39;100*100&#39;,&#39;@color&#39;)&quot;,
    //英文文本(句子)参1：句子的个数，参2：句子的最小个数  参3：句子的最大个数，没有参1时，参2参3才会生效
    &quot;Etext&quot;:&quot;@paragraph(1,1,3)&quot;,

    //中文文本(句子)参1：句子的个数，参2：句子的最小个数  参3：句子的最大个数，没有参1时，参2参3才会生效
    &quot;Ctext&quot;:&quot;@cparagraph(1,1,3)&quot;,

    //中国大区
    &quot;cregion&quot;:&quot;@region&quot;,
    // 省
    &quot;cprovince&quot;:&quot;@province&quot;,
    //市
    &quot;ccity&quot;:&quot;@city&quot;,
    //省 + 市
    &quot;ss&quot;:&quot;@city(true)&quot;,
    //县
    &quot;country&quot;:&quot;@county&quot;,
    //省市县
    &quot;countrysx&quot;:&quot;@county(true)&quot;,
    //邮政编码
    &quot;code&quot;:&quot;@zip&quot;

  &#125;]
&#125;)

// 输出结果
// console.log(data);
</code></pre>
<h2 id="mockjs语法规范"><a href="#mockjs语法规范" class="headerlink" title="mockjs语法规范"></a>mockjs语法规范</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：</p>
<pre><code>// 属性名   name
// 生成规则 rule
// 属性值   value
&#39;name|rule&#39;: value
</code></pre>
<p>注意：属性名 和 生成规则 之间用竖线 | 分隔。<br>生成规则 是可选的。<br>生成规则 有 7 种格式：</p>
<p> <code>&#39;name|min-max&#39;: value &#39;name|count&#39;: value &#39;name|min-max.dmin-dmax&#39;: value &#39;name|min-max.dcount&#39;: value &#39;name|count.dmin-dmax&#39;: value &#39;name|count.dcount&#39;: value</code></p>
<p>//属性值自动加 1，初始值为 <code>number</code> ‘name|+step’: value    </p>
<p>生成规则 的 含义 需要依赖 属性值的类型 才能确定。</p>
<p>属性值 中可以含有 @占位符。</p>
<p>属性值 还指定了最终值的初始值和类型。</p>
<ol>
<li><p>属性值是字符串 String</p>
<p> ‘name|min-max’: string</p>
<p> 通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。</p>
<p> ‘name|count’: string</p>
<p> 通过重复 string 生成一个字符串，重复次数等于 count。</p>
</li>
<li><p>属性值是数字 Number</p>
<p> ‘name|+1’: number</p>
<p> 属性值自动加 1，初始值为 number。</p>
<p> ‘name|min-max’: number</p>
<p> 生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。</p>
<p> ‘name|min-max.dmin-dmax’: number</p>
<p> 生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。</p>
</li>
<li><p>属性值是布尔型 Boolean</p>
<p> ‘name|1’: boolean</p>
<p> 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</p>
<p> ‘name|min-max’: value</p>
<p> 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</p>
</li>
<li><p>属性值是对象 Object</p>
<p> ‘name|count’: object</p>
<p> 从属性值 object 中随机选取 count 个属性。</p>
<p> ‘name|min-max’: object</p>
<p> 从属性值 object 中随机选取 min 到 max 个属性。</p>
</li>
<li><p>属性值是数组 Array</p>
<p> ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。</p>
<p> ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。</p>
<p> ‘name|min-max’: array</p>
<p> 通过重复属性值 array 生成一个新数组，重复次数大于等于 min，小于等于 max。</p>
<p> ‘name|count’: array</p>
<p> 通过重复属性值 array 生成一个新数组，重复次数为 count。</p>
</li>
<li><p>属性值是函数 Function</p>
<p> ‘name’: function</p>
<p> 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。</p>
</li>
</ol>
<h1 id="Mock-setup"><a href="#Mock-setup" class="headerlink" title="Mock.setup()"></a>Mock.setup()</h1><p>Mock.setup( settings )</p>
<p>配置拦截 Ajax 请求时的行为。支持的配置项有：timeout</p>
<p>指定被拦截的 Ajax 请求的响应时间，单位是毫秒。</p>
<p>值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；</p>
<p>也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。</p>
<pre><code>  Mock.setup(&#123;
    timeout: 400
&#125;)
Mock.setup(&#123;
    timeout: &#39;200-600&#39;
&#125;)
</code></pre>
<p>目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。</p>
<h1 id="Mock-Random-扩展方法"><a href="#Mock-Random-扩展方法" class="headerlink" title="Mock.Random 扩展方法"></a>Mock.Random 扩展方法</h1><pre><code>// 引入 Mock
var Mock = require(&#39;mockjs&#39;)
var random = Mock.Random;
//扩展数据模板
random.extend(&#123;
  type: function (index:number) &#123;
    const types = [&#39;products&#39;, &#39;industryApp&#39;, &#39;solution&#39;, &#39;experts&#39;];
    return this.pick(types[index])
  &#125;
&#125;);

// 定义数据类型
const  menuSource:Array&lt;any&gt; = [];
 menuSource[0] = Mock.mock(&#123;
  &quot;type&quot;: &quot;@type(0)&quot;,
   &#39;data|3-4&#39;:[&#123;
     &#39;id|+1&#39;: 1,
     name: &quot;@ctitle( 4,6)&quot;,
     &quot;childs|5-10&quot;: [&#123;
       &#39;id|+1&#39;: 1,
       name: &quot;@ctitle(4,6)&quot;,
     &#125;]
   &#125;]
&#125;);
// 输出结果
 console.log(data);
</code></pre>
<h1 id="mockjs获取前端传递的数据"><a href="#mockjs获取前端传递的数据" class="headerlink" title="mockjs获取前端传递的数据"></a>mockjs获取前端传递的数据</h1><pre><code>axios(&#123;
      method: &quot;get&quot;,
      url: &quot;/getGoods&quot;,
      data: &#123;
        id:2
      &#125;
    &#125;).then(data =&gt; &#123;
      //成功的回调函数，返回的是增加的数据
      console.log(data.data.data);
      this.url = data.data.data[0].goodsImg
    &#125;);
  &#125;

  Mock.mock(&quot;/getGoods&quot;, &quot;get&quot;, (config) =&gt; &#123;
  console.log(config);
  return data;
&#125;)
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/react-router-dom/" title="react-router-dom" itemprop="url">react-router-dom</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T07:01:00.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="React路由介绍"><a href="#React路由介绍" class="headerlink" title="React路由介绍"></a>React路由介绍</h1><p>现代的前端应用大多是SPA（单页面应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器的压力更小，为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。</p>
<ul>
<li>前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面）</li>
<li>前端路由是一套映射规则，在React中，是URL路径与组建的对应关系</li>
<li>使用React路由简单来说，就是配置路径和组件（配对）</li>
</ul>
<h1 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h1><ol>
<li>安装：yarn add react-router-dom</li>
<li>导入路由的核心组件：Router/Routes/Route/Link<br> import {BrowerRouter as Router, Routes, Route, Link} from ‘react-router-dom’</li>
<li>使用Router组件包裹整个应用</li>
</ol>
<p>4.使用Link组件作为导航菜单（路由入口）<br><code>&lt;Link to=&quot;\first&quot;&gt;页面&lt;/Link&gt; </code><br>5.使用Route组件配置路由规则和要展示的组件（路由出口）<br>    const First = ()=&gt;<p>页面一的页面内容</p><br>    <Router><br>            <div className="App"><br>                <Link to="\first"><br>                    页面一<br>                </Link><br>                <Routes><br>                &lt;Route path=”/first” element={<First/>}&gt;</Route><br>            </Routes><br>         </div><br>    </Router></p>
<h2 id="常用组件说明"><a href="#常用组件说明" class="headerlink" title="常用组件说明"></a>常用组件说明</h2><ul>
<li><p>Router组件：包裹整个应用，一个React应用只需要使用一次</p>
</li>
<li><p>两种常用的Router：HashRouter和BrowserRouter</p>
</li>
<li><p>HashRouter：使用URL的哈希值实现（localhost:3000/#/first）</p>
</li>
<li><p>（推荐）BrowserRouter：使用H5的history API实现（localhost:3000/first）</p>
</li>
<li><p>Link组件：用于指定导航链接（a标签）</p>
<p>  //to属性：浏览器地址栏中的pathname（location.pathname）</p>
  <Link to="/first">页面一</Link></li>
<li><p>Route组件：指定路由展示组件相关信息</p>
<p>  //path属性：展示的组件<br>  //element属性：展示的内容<br>  //Route组件写在哪，渲染的组件就展示在哪<br>  &lt;Route path=”/first” element={<First/>}&gt;</Route></p>
</li>
</ul>
<h1 id="路由的执行过程"><a href="#路由的执行过程" class="headerlink" title="路由的执行过程"></a>路由的执行过程</h1><ol>
<li>点击Link组件（a标签），修改了浏览器地址栏中的url。</li>
<li>React路由监听到地址栏url的变化。</li>
<li>React路由内部遍历所有的Route组件，使用路由规则（path）与pathname进行匹配。</li>
<li>当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容。</li>
</ol>
<h1 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h1><p>默认路由：表示进入页面时就会匹配的路由<br>默认路由path为：/</p>
<pre><code>&lt;Route path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&lt;/Route&gt;
</code></pre>
<h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><h2 id="模糊匹配模式"><a href="#模糊匹配模式" class="headerlink" title="模糊匹配模式"></a>模糊匹配模式</h2><p>当Link组件的to属性值为”/login”时，默认路由也会被匹配成功。<br>默认情况下，React路由是模糊匹配方式，模糊匹配规则：只要pathname以path开头就会匹配成功</p>
<pre><code>&lt;Link to=&quot;/login&quot;&gt;登录页面&lt;/Link&gt;
&lt;Route path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&gt;   匹配成功

//path代表Route组件的path属性
//pathname代表Link组件的to属性（也就是location.pathname）
</code></pre>
<h2 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h2><p>给Route组件添加exact属性，让其变为精确匹配模式。精确匹配：只有当path和pathname完全匹配时才会展示该路由</p>
<pre><code>//此时，该组件只能匹配pathname=&quot;/&quot;这一种情况
&lt;Route exact path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&gt;&lt;/Route&gt;
</code></pre>
<p>推荐：给默认路由添加exact属性。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/bootstrap/" title="bootstrap" itemprop="url">bootstrap</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T06:58:58.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;Bootstrap 实例 - 响应式的列重置&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

   &lt;div class = &quot;container&quot;&gt;&lt;!--      .container 类用于固定宽度并支持响应式布局的容器--&gt;
      123
   &lt;/div&gt;
   &lt;div class=&quot;container-fluid&quot;&gt; &lt;!--      .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。--&gt;
      456
   &lt;/div&gt;
   &lt;table class=&quot;table table-bordered&quot;&gt;&lt;!--      添加 .table-bordered 类为表格和其中的每个单元格增加边框。--&gt;
      &lt;tr&gt;
         &lt;td&gt;姓名&lt;/td&gt;
         &lt;td&gt;科目&lt;/td&gt;
         &lt;td&gt;成绩&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;夏明&lt;/td&gt;
         &lt;td&gt;数学&lt;/td&gt;
         &lt;td&gt;149&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;徐雪&lt;/td&gt;
         &lt;td&gt;英语&lt;/td&gt;
         &lt;td&gt;139&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>要使用boostrap，下面这些代码是必须要添加上的：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
&lt;/div&gt;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/29/react-redux/" title="react-redux" itemprop="url">react-redux</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-29T02:46:01.000Z" itemprop="datePublished"> Published 2022-01-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux的组成"><a href="#redux的组成" class="headerlink" title="redux的组成"></a>redux的组成</h2><h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state-状态"></a>state-状态</h3><p>就是我们传递的数据，我们在用React开发项目的时候，大致可以把State分成三类：</p>
<ul>
<li><p>DomainDate：可以理解为服务器端的数据，比如：获取用户的信息，商品的列表等等</p>
</li>
<li><p>UI State：决定当前UI展示的状态，比如：弹框的显示隐藏，受控组件等等</p>
</li>
<li><p>App State：App级别的状态，比如：当前是否请求loading，当前路由信息等可能被多个和组件去使用到的状态。</p>
</li>
</ul>
<h3 id="Action-事件"><a href="#Action-事件" class="headerlink" title="Action-事件"></a>Action-事件</h3><p>Action是把数据从应用传到store的载体，它是store数据的唯一来源，一般来说，我们可以通过store.dispatch()将action传递给store</p>
<p><strong>Action特点：</strong></p>
<ul>
<li><p>Action的本质就是一个javascript的普通对象</p>
</li>
<li><p>Action对象内部必须要有一个<strong>type</strong>属性来表示要执行的动作</p>
</li>
<li><p>多数情况下，这个<strong>type</strong>会被定义成字符串常量</p>
</li>
<li><p>除了<strong>type</strong>之外，action的结构随意进行定义</p>
</li>
<li><p>而我们在项目中，更多的喜欢用<strong>action</strong>创建函数（就是创建action的地方）</p>
</li>
<li><p><strong>只是描述了有事情要发生，并没有描述如何去更新state</strong></p>
</li>
</ul>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p><strong>reducer</strong>本质就是一个函数，它用来<strong>响应</strong>发送过来的<strong>actions</strong>，然后经过处理，把<strong>state</strong>发送给<strong>Store</strong>的</p>
<p><strong>注意：</strong>在reducer函数中，需要return返回值，这样Store才能接收到数据，函数会接收两个参数，第一个参数是初始化的state，第二个参数是action</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store就是把action与reducer联系到一起的对象</p>
<p>主要职责：</p>
<ul>
<li>维持应用的state</li>
<li>提供getState()方法获取state</li>
<li>提供dispatch()方法发送action</li>
<li>通过subscribe()来注册监听</li>
<li>通过subscribe()返回值注销监听</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>构建react项目</p>
<p>  <code>npx create-react-app redux-demo</code></p>
</li>
<li><p>删除多余的文件<br>(留下index.css,index.js,App.js)</p>
</li>
<li><p>在pages目录下创建Home组件</p>
</li>
<li><p>编写一个简单的结构样式</p>
<p>  <code>&lt;button&gt;发送一个action&lt;/button&gt;</code></p>
</li>
<li><p>在App.js中引入这个组件</p>
</li>
<li><p>安装redux</p>
<p>  <code>yarn add redux</code></p>
<h2 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h2></li>
<li><p>在根目录下创建一个文件夹action</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建Action</p>
<p>  const senAction = ()=&gt;{…};</p>
</li>
<li><p>在action创建函数里面利用return，返回一个action对象，注意需要携带type属性</p>
<p>  const sendAction=()=&gt;{return{type:”send_action”, value:”发送了一个action”}}</p>
</li>
<li><p>把这个action创建函数进行导出</p>
<p>  module.exports = {sendAction}</p>
<h2 id="创建一个Reducer"><a href="#创建一个Reducer" class="headerlink" title="创建一个Reducer"></a>创建一个Reducer</h2></li>
<li><p>在根目录下创建一个reducer</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建reducer，注意reducer要接收两个参数</p>
<p>  const rootReducer = (state, action) =&gt;{…};</p>
</li>
<li><p>第一个参数是默认状态，我们可以定义一个初始化的state，然后进行赋值</p>
<p>  const initState = {value:”默认值”}<br>  const rootReducer = (state = initState, action)=&gt;{…};</p>
</li>
<li><p>在函数里面判断第二个参数action的type是否是我们发送的</p>
</li>
<li><p>如果是的话，我们可以通过return返回新的state</p>
</li>
<li><p>把reducer进行导出</p>
</li>
</ul>
<h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2><ul>
<li><p>在根目录下创建一个文件夹store</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建store，注意createStore函数里面第一个参数接收的是reducer</p>
<pre><code>  import &#123;createStore&#125; from &quot;redux&quot;;
  const store = createStore&#123;reducer&#125;;
</code></pre>
</li>
<li><p>我们需要导入刚刚创建的reducer，然后设置到函数里面去</p>
</li>
<li><p>createStore的返回值就是我们构建好的store，然后进行导出</p>
</li>
</ul>
<h1 id="react-redux基本使用"><a href="#react-redux基本使用" class="headerlink" title="react-redux基本使用"></a>react-redux基本使用</h1><ul>
<li><p>在app.js中导入Provider组件</p>
<p>  <code>import &#123;Provider&#125; from &#39;react-redux&#39;</code></p>
</li>
<li><p>利用Provider组件将我们整个结构进行包裹，并且传递store</p>
<pre><code>  function App()&#123;
      return (&lt;Provider store = &#123;store&#125;&gt;&lt;/Provider)
  &#125;
</code></pre>
</li>
<li><p>导入connect方法</p>
<p>  <code>import &#123;connect&#125; from &quot;react-redux&quot;;</code></p>
</li>
<li><p>调用connect方法</p>
<p>  <code>connect(...)(Component)</code></p>
</li>
</ul>
<p>connect参数说明：</p>
<ul>
<li><p><strong>mapStateToProps(state, ownProps) 这个函数允许我们将store中的数据作为props绑定到组件上</strong></p>
</li>
<li><p><strong>mapDisPatchToProps(dispatch, ownProps) 将action作为props绑定到我们自己的函数中，dispatch就是store.dispatch(), ownProps自己的props</strong></p>
</li>
<li><p>mergeProps(stateProps, dispatchProps, ownProps) 不管是stateProps还是dispatchProps，都需要和ownProps merge之后才会被赋给我们的组件，通常情况下，可以不传这个参数，connect就会使用Object.assign替代该方法</p>
</li>
</ul>
<h2 id="利用connect方法让我们组件与store关联"><a href="#利用connect方法让我们组件与store关联" class="headerlink" title="利用connect方法让我们组件与store关联"></a>利用connect方法让我们组件与store关联</h2><ul>
<li><p>在组件ComA和ComB，分别导入connect方法</p>
<p>  import {connect} from ‘react-redux’</p>
</li>
<li><p>利用connect()方法来对我们组件进行加强，并且导出</p>
<p>  export default connect(mapStateToProps, mapDisPatchToProps)(Home)</p>
</li>
<li><p>组件ComA属于发送方，所以要实现第二个参数</p>
</li>
<li><p>组件ComB属于接收方，所以要实现第一个参数</p>
</li>
</ul>
<p>//数据转换流程<br>//mapDispatchToProps把方法的返回值传递给了counter组件的内部，<br>//这样组件就可以通过this.props拿到要发送的action的方法，事件触发action的发送<br>//reducer来进行接收action，返回值返回给store， store全局状态管理容器，<br>//store与Provider存在绑定关系，store拿到数据后，就会传递给mapStateToProps，<br>// 这个函数拿到了最新的值之后。就通过return把值返回给组件的内部，<br>// 组件通过this.props拿到传递过来的数据了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/09/es6/" title="es6" itemprop="url">es6</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-09T07:26:41.000Z" itemprop="datePublished"> Published 2022-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#let和const#</p>
<p><strong>let 声明的变量只在 let 命令所在的代码块内有效。</strong></p>
<p><strong>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</strong></p>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>基本用法:</p>
<pre><code>&#123;
  let a = 0;
  a   // 0
&#125;
a   // 报错 ReferenceError: a is not defined
</code></pre>
<p>代码块内有效</p>
<p><em>let 是在代码块内有效，var 是在全局范围内有效:</em></p>
<pre><code>&#123;
  let a = 0;
  var b = 1;
&#125;
a  // ReferenceError: a is not defined
b  // 1
</code></pre>
<p><em>不能重复声明，let 只能声明一次 var 可以声明多次:</em></p>
<pre><code>let a = 1;
let a = 2;
var b = 3;
var b = 4;
a  // Identifier &#39;a&#39; has already been declared
b  // 4
</code></pre>
<p>for 循环计数器很适合用 let</p>
<pre><code>for (var i = 0; i &lt; 10; i++) &#123;
  setTimeout(function()&#123;
    console.log(i);
  &#125;)
&#125;
// 输出十个 10
for (let j = 0; j &lt; 10; j++) &#123;
  setTimeout(function()&#123;
    console.log(j);
  &#125;)
&#125;
// 输出 0123456789
</code></pre>
<p>变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。</p>
<p>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。<br>不存在变量提升</p>
<p>let 不存在变量提升，var 会变量提升:</p>
<pre><code>console.log(a);  //ReferenceError: a is not defined
let a = &quot;apple&quot;;

console.log(b);  //undefined
var b = &quot;banana&quot;;
</code></pre>
<p>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。</p>
<p>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。</p>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p><strong>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</strong></p>
<p>基本用法:</p>
<pre><code>const PI = &quot;3.1415926&quot;;
PI  // 3.1415926

const MY_AGE;  // SyntaxError: Missing initializer in const declaration    
</code></pre>
<p>暂时性死区:</p>
<pre><code>var PI = &quot;a&quot;;
if(true)&#123;
  console.log(PI);  // ReferenceError: PI is not defined
  const PI = &quot;3.1415926&quot;;
&#125;
</code></pre>
<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>
<p><strong>注意要点</strong></p>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<p>#解构赋值#</p>
<p>解构赋值是对赋值运算符的扩展。<strong>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</strong></p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。<br>解构模型</p>
<p>在解构中，有下面两部分参与：<strong>解构的源，解构赋值表达式的右边部分；解构的目标，解构赋值表达式的左边部分。</strong></p>
<h2 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h2><p>基本</p>
<pre><code>let [a, b, c] = [1, 2, 3];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可嵌套</p>
<pre><code>let [a, [[b], c]] = [1, [[2], 3]];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可忽略</p>
<pre><code>let [a, , b] = [1, 2, 3];
// a = 1
// b = 3
</code></pre>
<p>不完全解构</p>
<pre><code>let [a = 1, b] = []; // a = 1, b = undefined
</code></pre>
<p>剩余运算符</p>
<pre><code>let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
</code></pre>
<p>###字符串等###</p>
<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<pre><code>let [a, b, c, d, e] = &#39;hello&#39;;
// a = &#39;h&#39;
// b = &#39;e&#39;
// c = &#39;l&#39;
// d = &#39;l&#39;
// e = &#39;o&#39;
</code></pre>
<p>解构默认值</p>
<pre><code>let [a = 2] = [undefined]; // a = 2
</code></pre>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<pre><code>let [a = 3, b = a] = [];     // a = 3, b = 3
let [a = 3, b = a] = [1];    // a = 1, b = 1
let [a = 3, b = a] = [1, 2]; // a = 1, b = 2
</code></pre>
<p>a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3<br>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1<br>a 与 b 正常解构赋值，匹配结果：a = 1，b = 2 </p>
<h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3><p>基本</p>
<pre><code>let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
// foo = &#39;aaa&#39;
// bar = &#39;bbb&#39;
 
let &#123; baz : foo &#125; = &#123; baz : &#39;ddd&#39; &#125;;
// foo = &#39;ddd&#39;
</code></pre>
<p>可嵌套可忽略</p>
<pre><code>let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123; y &#125;] &#125; = obj;
// x = &#39;hello&#39;
// y = &#39;world&#39;
let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123;  &#125;] &#125; = obj;
// x = &#39;hello&#39;
</code></pre>
<p>不完全解构</p>
<pre><code>let obj = &#123;p: [&#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [&#123; y &#125;, x ] &#125; = obj;
// x = undefined
// y = &#39;world&#39;
</code></pre>
<p>剩余运算符</p>
<pre><code>let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;;
// a = 10
// b = 20
// rest = &#123;c: 30, d: 40&#125;
</code></pre>
<p>解构默认值</p>
<pre><code>let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;
// a = 3; b = 5;
let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;
// aa = 3; bb = 5;
</code></pre>
<p>#ES6 Map与Set#</p>
<p>##Map 对象##</p>
<p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>Maps 和 Objects 的区别：</p>
<pre><code>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。
</code></pre>
<p>##Map 中的 key##</p>
<pre><code>var myMap = new Map();
var keyString = &quot;a string&quot;; 
 
myMap.set(keyString, &quot;和键&#39;a string&#39;关联的值&quot;);
 
myMap.get(keyString);    // &quot;和键&#39;a string&#39;关联的值&quot;
myMap.get(&quot;a string&quot;);   // &quot;和键&#39;a string&#39;关联的值&quot;
                         // 因为 keyString === &#39;a string&#39;
</code></pre>
<p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p>
<p>###Map 的迭代###</p>
<p>对 Map 进行遍历，以下两个最高级。<br><strong>for…of</strong></p>
<pre><code>var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);

// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

for (var [key, value] of myMap) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
for (var [key, value] of myMap.entries()) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */

// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;

for (var key of myMap.keys()) &#123;
  console.log(key);
&#125;
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */

// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;
for (var value of myMap.values()) &#123;
  console.log(value);
&#125;
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */

    forEach()
    var myMap = new Map();
    myMap.set(0, &quot;zero&quot;);
    myMap.set(1, &quot;one&quot;);
 
// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

    myMap.forEach(function(value, key) &#123;
      console.log(key + &quot; = &quot; + value);
    &#125;, myMap)
</code></pre>
<p>###Map 对象的操作###</p>
<p>####Map 与 Array的转换####</p>
<pre><code>var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];

// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象

var myMap = new Map(kvArray);

// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组

var outArray = Array.from(myMap);
</code></pre>
<p>####Map 的克隆####</p>
<pre><code>var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);
var myMap2 = new Map(myMap1);

console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。
</code></pre>
<h4 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h4><pre><code>var first = new Map([[1, &#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;],]);
var second = new Map([[1, &#39;uno&#39;], [2, &#39;dos&#39;]]);

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three

var merged = new Map([...first, ...second]);
</code></pre>
<p>##Set 对象##</p>
<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>###Set 中的特殊值###</p>
<p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<pre><code>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
undefined 与 undefined 是恒等的，所以不重复；
NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。
</code></pre>
<p>代码</p>
<pre><code>let mySet = new Set();
 
mySet.add(1); // Set(1) &#123;1&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125; 这里体现了值的唯一性
mySet.add(&quot;some text&quot;); 
// Set(3) &#123;1, 5, &quot;some text&quot;&#125; 这里体现了类型的多样性
var o = &#123;a: 1, b: 2&#125;; 
mySet.add(o);
mySet.add(&#123;a: 1, b: 2&#125;); 
// Set(5) &#123;1, 5, &quot;some text&quot;, &#123;…&#125;, &#123;…&#125;&#125; 
</code></pre>
<p>// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储<br>类型转换</p>
<p>Array</p>
<pre><code>// Array 转 Set
var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);
// 用...操作符，将 Set 转 Array
var myArray = [...mySet];
</code></pre>
<p>String</p>
<pre><code>// String 转 Set
var mySet = new Set(&#39;hello&#39;);  // Set(4) &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;&#125;
// 注：Set 中 toString 方法是不能将 Set 转换成 String
</code></pre>
<p>###Set 对象作用###</p>
<p>####数组去重####</p>
<pre><code>var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]
</code></pre>
<p>####并集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // &#123;1, 2, 3, 4&#125;
</code></pre>
<p>####交集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x =&gt; b.has(x))); // &#123;2, 3&#125;
</code></pre>
<p>####差集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x =&gt; !b.has(x))); // &#123;1&#125;
</code></pre>
<p>#字符串拓展方法#</p>
<p>##子串的识别##</p>
<p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p>
<ul>
<li><p><strong>includes()：返回布尔值，判断是否找到参数字符串。</strong></p>
</li>
<li><p><strong>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。</strong></p>
</li>
<li><p><strong>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。</strong></p>
</li>
</ul>
<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>
<pre><code>let string = &quot;apple,banana,orange&quot;;
string.includes(&quot;banana&quot;);     // true
string.startsWith(&quot;apple&quot;);    // true
string.endsWith(&quot;apple&quot;);      // false
string.startsWith(&quot;banana&quot;,6)  // true
</code></pre>
<p><strong>注意点</strong>：</p>
<ul>
<li><p>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</p>
</li>
<li><p>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/09/刷题经验/" title="刷题经验" itemprop="url">刷题经验</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-09T01:53:11.000Z" itemprop="datePublished"> Published 2022-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="链表求中点-："><a href="#链表求中点-：" class="headerlink" title="链表求中点 #："></a>链表求中点 #：</h1><pre><code>var slow = head, fast = head.next;
while(fast!=null &amp;&amp; fast.next!=null)&#123;
    slow = slow.next;
    fast = fast.next.next;
&#125;
</code></pre>
<h1 id="围成圆，提取的位置不能相邻-："><a href="#围成圆，提取的位置不能相邻-：" class="headerlink" title="围成圆，提取的位置不能相邻 #："></a>围成圆，提取的位置不能相邻 #：</h1><p>（采用枚举法）<br>两种情况：1.有头没尾；2.没头有尾</p>
<h1 id="三数之和："><a href="#三数之和：" class="headerlink" title="三数之和：#"></a>三数之和：#</h1><pre><code>var threeSum = function(nums) &#123;
    const len = nums.length;
    if(len &lt; 3) return [];
    nums.sort((a, b) =&gt; a - b);
    const resSet = new Set();
    for(let i = 0; i &lt; len - 2; i++) &#123;
        if(nums[i] &gt; 0) break;
        let l = i + 1, r = len - 1;
        while(l &lt; r) &#123;
            const sum = nums[i] + nums[l] + nums[r];
            if(sum &lt; 0) &#123; l++; continue &#125;;
            if(sum &gt; 0) &#123; r--; continue &#125;;
            resSet.add(`$&#123;nums[i]&#125;,$&#123;nums[l]&#125;,$&#123;nums[r]&#125;`);
            l++;
            r--;
        &#125;
    &#125;
    return Array.from(resSet).map(i =&gt; i.split(&quot;,&quot;));
&#125;;
</code></pre>
<h1 id="不需要额外空间的方法，就往位运算上想"><a href="#不需要额外空间的方法，就往位运算上想" class="headerlink" title="不需要额外空间的方法，就往位运算上想"></a>不需要额外空间的方法，就往位运算上想</h1><h1 id="map的使用："><a href="#map的使用：" class="headerlink" title="map的使用："></a>map的使用：</h1><pre><code>var majorityElement = function(nums) &#123;
    if(nums.length &lt; 3)&#123;
        return nums[0];
    &#125;

    var map = new Map()
    var count = Math.floor(nums.length/2);
    for(let i = 0;i&lt;nums.length;i++)&#123;
        if(map.get(nums[i]))&#123;
            map.set(nums[i], map.get(nums[i]) + 1)
            //修改value值
        &#125;
        else&#123;
            map.set(nums[i], 1)
        &#125;
    &#125;
    console.log(count)
    for (let key of map.keys()) &#123;
        if(map.get(key)&gt;count)&#123;
            //获取value的正确写法
            return key;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="子数组最大和："><a href="#子数组最大和：" class="headerlink" title="子数组最大和："></a>子数组最大和：</h1><pre><code>const maxSubArray = nums =&gt; &#123;
    // 数组长度，dp初始化
    const [len, dp] = [nums.length, [nums[0]]];
    // 最大值初始化为dp[0]
    let max = dp[0];
    for (let i = 1; i &lt; len; i++) &#123;
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        // 更新最大值
        max = Math.max(max, dp[i]);
    &#125;
    return max;
&#125;;
</code></pre>
<p>连续的思想包含在</p>
<pre><code>Math.max(dp[i - 1] + nums[i], nums[i])
</code></pre>
<h1 id="环形数组："><a href="#环形数组：" class="headerlink" title="环形数组："></a>环形数组：</h1><p>两种情况：一种是最大和子数组在数组内；一种是最大子数组在两边，这个时候除开最大子数组，中间的留下的就是最小子数组。</p>
<pre><code>var total = 0, maxSum = nums[0], curMax = 0, minSum = nums[0], curMin = 0;
for (let a of nums) &#123;
    curMax = Math.max(curMax + a, a);
    maxSum = Math.max(maxSum, curMax);
    curMin = Math.min(curMin + a, a);
    minSum = Math.min(minSum, curMin);
    total += a;
&#125;
return maxSum &gt; 0 ? Math.max(maxSum, total - minSum) : maxSum;
</code></pre>
<p>子数组最大积</p>
<pre><code>var maxProduct = function(nums) &#123;
 var a=1;  
var max=nums[0];

for(var num of nums)&#123;
    a=a*num;
    if(max&lt;a)max=a;
    if(num==0)a=1;

&#125;
a=1;
for(var i=nums.length-1;i&gt;=0;i--)&#123;
    a=a*nums[i];
    if(max&lt;a)max=a;
    if(nums[i]==0)a=1;
&#125;  
return max;
&#125;;
</code></pre>
<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><pre><code>ingredients.forEach(function(a)&#123;return new Set(a)&#125;)
[...new Set(supplies)]
</code></pre>
<p>不断重复的过程中添加新的元素，循环推出条件：没有新元素加入则退出。下面这个代码的循环推出条件值得参考。</p>
<pre><code>var findAllRecipes = function(recipes, ingredients, supplies) &#123;
    var intersect, result = [], valid, interact;
    ingredients.forEach(function(a)&#123;return new Set(a)&#125;)
    supplies.forEach(function(a)&#123;return new Set(a)&#125;)
    while(true)&#123;
        valid = false;
        for(let i = 0;i&lt;recipes.length;i++)&#123;
            if(result.indexOf(recipes[i])!=-1)&#123;
                continue
            &#125;
            interact = new Set(ingredients[i].filter(x =&gt; supplies.indexOf(x)!=-1));
            if([...interact].length == ingredients[i].length)&#123;
                valid = true;
                result.push(recipes[i]);
                supplies.push(recipes[i]);
            &#125;
        &#125;
        if (valid == false)&#123;
            break;
        &#125;
    &#125;
    return result;
&#125;;
</code></pre>
<h1 id="数组、字符串、整数互相转换："><a href="#数组、字符串、整数互相转换：" class="headerlink" title="数组、字符串、整数互相转换："></a>数组、字符串、整数互相转换：</h1><ul>
<li><p>split() 方法，功能：将字符串按某个字符切割成若干个字符串，并以数组形式返回，<code>arr.split(&quot;&quot;)</code></p>
</li>
<li><p>join() 方法 功能：将数组元素用某个字符连接成字符串， <code>arr.join(&quot;&quot;)</code></p>
</li>
<li><p>字符串转换成整数：parseInt，<code>parseInt(&#39;123&#39;)</code></p>
</li>
<li><p>将数值转换成字符串，<code>&#39;123&#39;.toString()</code></p>
</li>
</ul>
<h1 id="注意：1-lt-a-lt-2这种写法是错误的，应该改成1-lt-a-amp-amp-a-lt-2"><a href="#注意：1-lt-a-lt-2这种写法是错误的，应该改成1-lt-a-amp-amp-a-lt-2" class="headerlink" title="注意：1&lt;a&lt;=2这种写法是错误的，应该改成1&lt;a &amp;&amp; a&lt;=2"></a>注意：<code>1&lt;a&lt;=2</code>这种写法是错误的，应该改成<code>1&lt;a &amp;&amp; a&lt;=2</code></h1><h1 id="KMP算法："><a href="#KMP算法：" class="headerlink" title="KMP算法："></a>KMP算法：</h1><pre><code>function KMPNext(str)&#123;
    var next = [0];
    for(var i = 1, j = 0;i&lt;str.length;i++)&#123;
        while(j&gt;0 &amp;&amp; str[i]!=str[j])&#123;
            j = next[j-1];//这里其实是与前面的相比较，比如ABCDAB，B这个数的部分匹配值其实是与前面的ABCD中B相比较，如果相同则加一，不然归零。
            console.log(j);

        &#125;
        if(str[i] == str[j])&#123;
            j++;
        &#125;
        next[i] = j;

    &#125;
    return next;
&#125;
function KMPSearch(str1, str2)&#123;
    var next = KMPNext(str2);
    for(var i = 0, j = 0;i&lt;str1.length;i++)&#123;
        if(str1[i] == str2[j])&#123;
            j++;
        &#125;
        else&#123;
            i = i-(j-next[j]);
            j = 0;
        &#125;
        if(j == str2.length)&#123;
            return i-j+1;

        &#125;
    &#125;
    return -1;

&#125;
var str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;, str2 = &quot;ABCDABD&quot;;
console.log(KMPSearch(str1, str2));
</code></pre>
<h1 id="map删除某个key值："><a href="#map删除某个key值：" class="headerlink" title="map删除某个key值："></a>map删除某个key值：</h1><pre><code>map.delete(key)
map.keys()
map.values()
</code></pre>
<h1 id="实现单行文本在父元素中不换行-溢出部分变成省略号形式"><a href="#实现单行文本在父元素中不换行-溢出部分变成省略号形式" class="headerlink" title="实现单行文本在父元素中不换行, 溢出部分变成省略号形式"></a>实现单行文本在父元素中不换行, 溢出部分变成省略号形式</h1><p>CSS样式：</p>
<pre><code>.text-inner &#123;
    width: 500px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    border: 1px solid rgba(0,0,0,0.1);
    &#125;
</code></pre>
<p>text-overflow 属性指定当文本溢出包含它的元素时，应该如何显示。可以设置溢出后，文本被剪切、显示省略号 (…) 或显示自定义字符串（不是所有浏览器都支持）。</p>
<p>text-overflow 需要配合以下两个属性使用：<br>white-space: nowrap;<br>overflow: hidden;</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/06/php/" title="php" itemprop="url">php</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-06T11:43:01.000Z" itemprop="datePublished"> Published 2022-01-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="php变量"><a href="#php变量" class="headerlink" title="php变量"></a>php变量</h1><h2 id="PHP-变量规则"><a href="#PHP-变量规则" class="headerlink" title="PHP 变量规则"></a>PHP 变量规则</h2><ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）</li>
<li>变量名不能包含空格</li>
<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li>
</ul>
<pre><code>&lt;?php
    $txt=&quot;Hello world!&quot;;
    $x=5;
    $y=10.5;
    echo $txt.$x.$y
?&gt;
</code></pre>
<h2 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h2><p>变量的作用域是脚本中变量可被引用/使用的部分。</p>
<p>PHP 有四种不同的变量作用域：</p>
<ul>
<li><p>local</p>
</li>
<li><p>global</p>
</li>
<li><p>static</p>
</li>
<li><p>parameter</p>
</li>
</ul>
<h3 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h3><pre><code> &lt;?php
    $x=5; // 全局变量
    
    function myTest()
    &#123;
        $y=10; // 局部变量
        echo &quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;;
        echo &quot;变量 x 为: $x&quot;;
        echo &quot;&lt;br&gt;&quot;;
        echo &quot;变量 y 为: $y&quot;;
    &#125; 
    
    myTest();
    
    echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;
    echo &quot;变量 x 为: $x&quot;;
    echo &quot;&lt;br&gt;&quot;;
    echo &quot;变量 y 为: $y&quot;;
?&gt; 
</code></pre>
<p><strong>global</strong> 关键字用于函数内访问全局变量。在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：</p>
<pre><code>&lt;?php
    $x=5;
    $y=10;
     
    function myTest()
    &#123;
        global $x,$y;
        $y=$x+$y;
    &#125;
     
    myTest();
    echo $y; // 输出 15
?&gt;
</code></pre>
<h1 id="PHP-echo-语句"><a href="#PHP-echo-语句" class="headerlink" title="PHP echo 语句"></a>PHP echo 语句</h1><p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p>
<pre><code>&lt;?php
    echo &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;
    echo &quot;Hello world!&lt;br&gt;&quot;;
    echo &quot;我要学 PHP!&lt;br&gt;&quot;;
    echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;
?&gt;
</code></pre>
<h1 id="php数据类型"><a href="#php数据类型" class="headerlink" title="php数据类型"></a>php数据类型</h1><ul>
<li><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p>
</li>
<li><p>PHP 字符串：一个字符串是一串字符的序列，就像 “Hello world!”。你可以将任何文本放在单引号和双引号中。</p>
</li>
<li><p>PHP 布尔型：布尔型可以是 TRUE 或 FALSE。</p>
</li>
<li><p>PHP 数组：数组可以在一个变量中存储多个值。</p>
</li>
<li><p>PHP 对象：对象数据类型也可以用于存储数据。在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：</p>
<pre><code>  &lt;?php
      class Car
      &#123;
        var $color;
        function __construct($color=&quot;green&quot;) &#123;
          $this-&gt;color = $color;
        &#125;
        function what_color() &#123;
          return $this-&gt;color;
        &#125;
      &#125;
  ?&gt;
</code></pre>
</li>
</ul>
<p>以上实例中php关键字this就是指向当前对象实例的指针，不指向任何其他对象或类。</p>
<ul>
<li><p>PHP NULL 值:NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。可以通过设置变量值为 NULL 来清空变量数据：</p>
<pre><code>  &lt;?php
      $x=&quot;Hello world!&quot;;
      $x=null;
      var_dump($x);
  ?&gt;
</code></pre>
</li>
</ul>
<h1 id="PHP-类定义"><a href="#PHP-类定义" class="headerlink" title="PHP 类定义"></a>PHP 类定义</h1><p>PHP 定义类通常语法格式如下：</p>
<pre><code>&lt;?php
class phpClass &#123;
  var $var1;
  var $var2 = &quot;constant string&quot;;
  
  function myfunc ($arg1, $arg2) &#123;
     [..]
  &#125;
  [..]
&#125;
?&gt;
</code></pre>
<p>解析如下：</p>
<ul>
<li><p>类使用 class 关键字后加上类名定义。</p>
</li>
<li><p>类名后的一对大括号({})内可以定义变量和方法。</p>
</li>
<li><p>类的变量使用 var 来声明, 变量也可以初始化值。</p>
</li>
<li><p>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</p>
</li>
</ul>
<pre><code>&lt;?php
    class Site &#123;
      /* 成员变量 */
      var $url;
      var $title;
      
      /* 成员函数 */
      function setUrl($par)&#123;
         $this-&gt;url = $par;
      &#125;
      
      function getUrl()&#123;
         echo $this-&gt;url . PHP_EOL;
      &#125;
      
      function setTitle($par)&#123;
         $this-&gt;title = $par;
      &#125;
      
      function getTitle()&#123;
         echo $this-&gt;title . PHP_EOL;
      &#125;
    &#125;
?&gt;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/jQuery-bootstrap/" title="jQuery &amp; bootstrap">jQuery &amp; bootstrap<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/sort/" title="sort">sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Weiling Wu in Google. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2022 
		
		<a href="/about" target="_blank" title="Weiling Wu">Weiling Wu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
