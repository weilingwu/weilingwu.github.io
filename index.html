
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>font-end study</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Weiling Wu">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="font-end study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="font-end study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiling Wu">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="font-end study" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/katong.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.0.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="font-end study" title="font-end study"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="font-end study">font-end study</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/archives">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/CSS3/" title="CSS3" itemprop="url">CSS3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T08:19:43.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="position-的四个值：static、relative、absolute、fixed"><a href="#position-的四个值：static、relative、absolute、fixed" class="headerlink" title="position 的四个值：static、relative、absolute、fixed"></a>position 的四个值：static、relative、absolute、fixed</h1><ul>
<li><p>absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>relative：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</p>
</li>
<li><p>static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
</li>
</ul>
<h1 id="CSS-伪类-Pseudo-classes"><a href="#CSS-伪类-Pseudo-classes" class="headerlink" title="CSS 伪类(Pseudo-classes)"></a>CSS 伪类(Pseudo-classes)</h1><p>CSS伪类是用来添加一些选择器的特殊效果。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>伪类的语法：<code>selector:pseudo-class &#123;property:value;&#125;</code></p>
<p>CSS类也可以使用伪类：<code>selector.class:pseudo-class &#123;property:value;&#125;</code></p>
<h2 id="anchor伪类"><a href="#anchor伪类" class="headerlink" title="anchor伪类"></a>anchor伪类</h2><p>在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示<br>实例：</p>
<pre><code>a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */
a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */
a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */
a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */
</code></pre>
<p>注意： 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p>
<p>注意： 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p>
<p>注意：伪类的名称不区分大小写。</p>
<h2 id="伪类和CSS类"><a href="#伪类和CSS类" class="headerlink" title="伪类和CSS类"></a>伪类和CSS类</h2><p>伪类可以与 CSS 类配合使用：</p>
<pre><code>a.red:visited &#123;color:#FF0000;&#125;
 
&lt;a class=&quot;red&quot; href=&quot;css-syntax.html&quot;&gt;CSS 语法&lt;/a&gt;
</code></pre>
<p>如果在上面的例子的链接已被访问，它会显示为红色。</p>
<h2 id="CSS-first-child-伪类"><a href="#CSS-first-child-伪类" class="headerlink" title="CSS :first-child 伪类"></a>CSS :first-child 伪类</h2><p>您可以使用 :first-child 伪类来选择父元素的第一个子元素。</p>
<p>注意：在IE8的之前版本必须声明&lt;!DOCTYPE&gt; ，这样 :first-child 才能生效。<br>匹配第一个 <code>&lt;p&gt;</code> 元素</p>
<p>在下面的例子中，选择器匹配作为任何元素的第一个子元素的 <code>&lt;p&gt;</code> 元素：</p>
<pre><code>p:first-child
&#123;
    color:blue;
&#125;
</code></pre>
<p>匹配所有<code>&lt;p&gt;</code> 元素中的第一个 <code>&lt;i&gt;</code> 元素</p>
<p>在下面的例子中，选择相匹配的所有<p>元素的第一个 <code>&lt;i&gt;</code> 元素：</p>
<pre><code>p &gt; i:first-child
&#123;
    color:blue;
&#125;
</code></pre>
<p>匹配所有作为第一个子元素的 <p> 元素中的所有 <code>&lt;i&gt;</code> 元素</p>
<p>在下面的例子中，选择器匹配所有作为元素的第一个子元素的 <code>&lt;p&gt;</code> 元素中的所有 <code>&lt;i&gt;</code> 元素：</p>
<pre><code>p:first-child i
&#123;
    color:blue;
&#125;
</code></pre>
<h1 id="CSS-伪元素"><a href="#CSS-伪元素" class="headerlink" title="CSS 伪元素"></a>CSS 伪元素</h1><p>CSS伪元素是用来添加一些选择器的特殊效果。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>伪元素的语法：<code>selector:pseudo-element &#123;property:value;&#125;</code></p>
<p>CSS类也可以使用伪元素：<code>selector.class:pseudo-element &#123;property:value;&#125;</code></p>
<h2 id="first-line-伪元素"><a href="#first-line-伪元素" class="headerlink" title=":first-line 伪元素"></a>:first-line 伪元素</h2><p>“first-line” 伪元素用于向文本的首行设置特殊样式。</p>
<p>在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：</p>
<pre><code>p:first-line 
&#123;
    color:#ff0000;
    font-variant:small-caps;
&#125;
</code></pre>
<p>注意：”first-line” 伪元素只能用于块级元素。</p>
<h2 id="伪元素和CSS类"><a href="#伪元素和CSS类" class="headerlink" title="伪元素和CSS类"></a>伪元素和CSS类</h2><p>伪元素可以结合CSS类： </p>
<pre><code>p.article:first-letter &#123;color:#ff0000;&#125;

&lt;p class=&quot;article&quot;&gt;文章段落&lt;/p&gt;
</code></pre>
<p>上面的例子会使所有 class 为 article 的段落的首字母变为红色。</p>
<p>在下面的例子中，段落的第一个字母将显示为红色，其字体大小为 xx-large。第一行中的其余文本将为蓝色，并以小型大写字母显示。</p>
<p>段落中的其余文本将以默认字体大小和颜色来显示：</p>
<pre><code>p:first-letter
&#123;
    color:#ff0000;
    font-size:xx-large;
&#125;
p:first-line 
&#123;
    color:#0000ff;
    font-variant:small-caps;
&#125;
</code></pre>
<h2 id="CSS-before-伪元素"><a href="#CSS-before-伪元素" class="headerlink" title="CSS - :before 伪元素"></a>CSS - :before 伪元素</h2><p>“:before” 伪元素可以在元素的内容前面插入新内容。</p>
<p>下面的例子在每个 <code>&lt;h1&gt;</code>元素前面插入一幅图片：</p>
<pre><code>h1:before 
&#123;
    content:url(smiley.gif);
&#125;
</code></pre>
<h2 id="CSS-after-伪元素"><a href="#CSS-after-伪元素" class="headerlink" title="CSS - :after 伪元素"></a>CSS - :after 伪元素</h2><p>“:after” 伪元素可以在元素的内容之后插入新内容。</p>
<p>下面的例子在每个 <code>&lt;h1&gt;</code> 元素后面插入一幅图片：</p>
<pre><code>h1:after
&#123;
    content:url(smiley.gif);
&#125;
</code></pre>
<h1 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h1><ul>
<li><p><strong>伪类选择元素基于的是当前元素处于的状态</strong>，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</p>
</li>
<li><p>与伪类针对特殊状态的元素不同的是，<strong>伪元素是对元素中的特定内容进行操作</strong>，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。</p>
</li>
</ul>
<h1 id="弹性盒子-Flex-Box"><a href="#弹性盒子-Flex-Box" class="headerlink" title="弹性盒子(Flex Box)"></a>弹性盒子(Flex Box)</h1><ul>
<li><p>CSS3 弹性盒子（ Flexible Box 或 flexbox），<strong>是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</strong>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>
</li>
<li><p>弹性盒子由<strong>弹性容器</strong>(Flex container)和<strong>弹性子元素</strong>(Flex item)组成。弹性容器通过设置 <strong>display</strong> 属性的值为 flex 或 inline-flex将其定义为弹性容器。弹性容器内包含了一个或多个弹性子元素。</p>
  <!DOCTYPE html>
  <html>
  <head>
  <style>
  .flex-container {
      display: -webkit-flex;
      display: flex;
      width: 400px;
      height: 250px;
      background-color: lightgrey;
  }
   
<p>  .flex-item {</p>
<pre><code>  background-color: cornflowerblue;
  width: 100px;
  height: 100px;
  margin: 10px;
</code></pre>
<p>  }<br>  </style></p>
  </head>
  <body>
   
  <div class="flex-container">
    <div class="flex-item">flex item 1</div>
    <div class="flex-item">flex item 2</div>
    <div class="flex-item">flex item 3</div> 
  </div>
   
  </body>
  </html></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/mockjs/" title="mockjs" itemprop="url">mockjs</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T08:01:45.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="为什么使用mockjs"><a href="#为什么使用mockjs" class="headerlink" title="为什么使用mockjs"></a>为什么使用mockjs</h1><p>（原文出自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d812ce349265%EF%BC%89">https://www.jianshu.com/p/d812ce349265）</a></p>
<p>在做开发时，当后端的接口还未完成，前端为了不影响工作效率，手动模拟后端接口，</p>
<pre><code>1.我们可以使用json文件来模拟后台数据，但比较局限，无法模拟数据的增删改查
2.使用json-server模拟，但不能随机生成所需数据
3.使用mockjs模拟后端接口，可随机生成所需数据，可模拟对数据的增删改查
</code></pre>
<h1 id="mock优点"><a href="#mock优点" class="headerlink" title="mock优点"></a>mock优点</h1><pre><code>1.前后端分离，
2.可随机生成大量的数据
3.用法简单
4.数据类型丰富
5.可扩展数据类型
6.在已有接口文档的情况下，我们可以直接按照接口文档来开发，将相应的字段写好，在接口完成 之后，只需要改变url地址即可。
</code></pre>
<h1 id="mock使用"><a href="#mock使用" class="headerlink" title="mock使用"></a>mock使用</h1><pre><code>npm install mockjs --save-dev
// 引入 Mock
var Mock = require(&#39;mockjs&#39;)

// 定义数据类型
var data = Mock.mock(&#123;
  // 20条数据
  &quot;data|20&quot;: [&#123;
    // 商品种类
    &quot;goodsClass&quot;: &quot;女装&quot;,
    // 商品Id
    &quot;goodsId|+1&quot;: 1,
    //商品名称
    &quot;goodsName&quot;: &quot;@ctitle(10)&quot;,
    //商品地址
    &quot;goodsAddress&quot;: &quot;@county(true)&quot;,
    //商品等级评价★
    &quot;goodsStar|1-5&quot;: &quot;★&quot;,
    //商品图片
    &quot;goodsImg&quot;: &quot;@Image(&#39;100x100&#39;,&#39;@color&#39;,&#39;小甜甜&#39;)&quot;,
    //商品售价
    &quot;goodsSale|30-500&quot;: 30

  &#125;]
&#125;)
// 输出结果随机生成的数据（node index.js）
 console.log(data);
</code></pre>
<h1 id="mockjs的数据类型-及-语法规范"><a href="#mockjs的数据类型-及-语法规范" class="headerlink" title="mockjs的数据类型 及 语法规范"></a>mockjs的数据类型 及 语法规范</h1><h2 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h2><p>Mock.Random是一个工具类，用于生成各种随机数据。<br>Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数])</p>
<h2 id="定义数据类型，详情见官方文档"><a href="#定义数据类型，详情见官方文档" class="headerlink" title="定义数据类型，详情见官方文档"></a>定义数据类型，详情见官方文档</h2><pre><code>// 引入 Mock
var Mock = require(&#39;mockjs&#39;)

// 定义数据类型
var data = Mock.mock(&#123;
  // 20条数据
  &quot;data|3&quot;: [&#123;
    // 商品种类
    &quot;goodsClass&quot;: &quot;女装&quot;,
    // 商品Id
    &quot;goodsId|+1&quot;: 1,
    //商品名称
    &quot;goodsName&quot;: &quot;@ctitle(10)&quot;,
    //商品地址
    &quot;goodsAddress&quot;: &quot;@county(true)&quot;,
    //商品等级评价★
    &quot;goodsStar|1-5&quot;: &quot;★&quot;,
    //商品图片
    &quot;goodsImg&quot;: &quot;@Image(&#39;100x100&#39;,&#39;@color&#39;,&#39;小甜甜&#39;)&quot;,
    //商品售价
    &quot;goodsSale|30-500&quot;: 30,

    // 邮箱：
    &quot;email&quot;: &quot;@email&quot;,
    // 颜色
    &quot;color&quot;: &quot;@color&quot;,

    // name
    &quot;name&quot;: &quot;@name&quot;,

    //img,参数1：背景色，参2：前景色，参3：图片的格式，默认png，参4：图片上的文字

    &quot;img&quot;: &quot;@image(&#39;100*100&#39;,&#39;@color&#39;)&quot;,
    //英文文本(句子)参1：句子的个数，参2：句子的最小个数  参3：句子的最大个数，没有参1时，参2参3才会生效
    &quot;Etext&quot;:&quot;@paragraph(1,1,3)&quot;,

    //中文文本(句子)参1：句子的个数，参2：句子的最小个数  参3：句子的最大个数，没有参1时，参2参3才会生效
    &quot;Ctext&quot;:&quot;@cparagraph(1,1,3)&quot;,

    //中国大区
    &quot;cregion&quot;:&quot;@region&quot;,
    // 省
    &quot;cprovince&quot;:&quot;@province&quot;,
    //市
    &quot;ccity&quot;:&quot;@city&quot;,
    //省 + 市
    &quot;ss&quot;:&quot;@city(true)&quot;,
    //县
    &quot;country&quot;:&quot;@county&quot;,
    //省市县
    &quot;countrysx&quot;:&quot;@county(true)&quot;,
    //邮政编码
    &quot;code&quot;:&quot;@zip&quot;

  &#125;]
&#125;)

// 输出结果
// console.log(data);
</code></pre>
<h2 id="mockjs语法规范"><a href="#mockjs语法规范" class="headerlink" title="mockjs语法规范"></a>mockjs语法规范</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：</p>
<pre><code>// 属性名   name
// 生成规则 rule
// 属性值   value
&#39;name|rule&#39;: value
</code></pre>
<p>注意：属性名 和 生成规则 之间用竖线 | 分隔。<br>生成规则 是可选的。<br>生成规则 有 7 种格式：</p>
<p> <code>&#39;name|min-max&#39;: value &#39;name|count&#39;: value &#39;name|min-max.dmin-dmax&#39;: value &#39;name|min-max.dcount&#39;: value &#39;name|count.dmin-dmax&#39;: value &#39;name|count.dcount&#39;: value</code></p>
<p>//属性值自动加 1，初始值为 <code>number</code> ‘name|+step’: value    </p>
<p>生成规则 的 含义 需要依赖 属性值的类型 才能确定。</p>
<p>属性值 中可以含有 @占位符。</p>
<p>属性值 还指定了最终值的初始值和类型。</p>
<ol>
<li><p>属性值是字符串 String</p>
<p> ‘name|min-max’: string</p>
<p> 通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。</p>
<p> ‘name|count’: string</p>
<p> 通过重复 string 生成一个字符串，重复次数等于 count。</p>
</li>
<li><p>属性值是数字 Number</p>
<p> ‘name|+1’: number</p>
<p> 属性值自动加 1，初始值为 number。</p>
<p> ‘name|min-max’: number</p>
<p> 生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。</p>
<p> ‘name|min-max.dmin-dmax’: number</p>
<p> 生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。</p>
</li>
<li><p>属性值是布尔型 Boolean</p>
<p> ‘name|1’: boolean</p>
<p> 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</p>
<p> ‘name|min-max’: value</p>
<p> 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</p>
</li>
<li><p>属性值是对象 Object</p>
<p> ‘name|count’: object</p>
<p> 从属性值 object 中随机选取 count 个属性。</p>
<p> ‘name|min-max’: object</p>
<p> 从属性值 object 中随机选取 min 到 max 个属性。</p>
</li>
<li><p>属性值是数组 Array</p>
<p> ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。</p>
<p> ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。</p>
<p> ‘name|min-max’: array</p>
<p> 通过重复属性值 array 生成一个新数组，重复次数大于等于 min，小于等于 max。</p>
<p> ‘name|count’: array</p>
<p> 通过重复属性值 array 生成一个新数组，重复次数为 count。</p>
</li>
<li><p>属性值是函数 Function</p>
<p> ‘name’: function</p>
<p> 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。</p>
</li>
</ol>
<h1 id="Mock-setup"><a href="#Mock-setup" class="headerlink" title="Mock.setup()"></a>Mock.setup()</h1><p>Mock.setup( settings )</p>
<p>配置拦截 Ajax 请求时的行为。支持的配置项有：timeout</p>
<p>指定被拦截的 Ajax 请求的响应时间，单位是毫秒。</p>
<p>值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容；</p>
<p>也可以是横杠 ‘-‘ 风格的字符串，例如 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是’10-100’。</p>
<pre><code>  Mock.setup(&#123;
    timeout: 400
&#125;)
Mock.setup(&#123;
    timeout: &#39;200-600&#39;
&#125;)
</code></pre>
<p>目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。</p>
<h1 id="Mock-Random-扩展方法"><a href="#Mock-Random-扩展方法" class="headerlink" title="Mock.Random 扩展方法"></a>Mock.Random 扩展方法</h1><pre><code>// 引入 Mock
var Mock = require(&#39;mockjs&#39;)
var random = Mock.Random;
//扩展数据模板
random.extend(&#123;
  type: function (index:number) &#123;
    const types = [&#39;products&#39;, &#39;industryApp&#39;, &#39;solution&#39;, &#39;experts&#39;];
    return this.pick(types[index])
  &#125;
&#125;);

// 定义数据类型
const  menuSource:Array&lt;any&gt; = [];
 menuSource[0] = Mock.mock(&#123;
  &quot;type&quot;: &quot;@type(0)&quot;,
   &#39;data|3-4&#39;:[&#123;
     &#39;id|+1&#39;: 1,
     name: &quot;@ctitle( 4,6)&quot;,
     &quot;childs|5-10&quot;: [&#123;
       &#39;id|+1&#39;: 1,
       name: &quot;@ctitle(4,6)&quot;,
     &#125;]
   &#125;]
&#125;);
// 输出结果
 console.log(data);
</code></pre>
<h1 id="mockjs获取前端传递的数据"><a href="#mockjs获取前端传递的数据" class="headerlink" title="mockjs获取前端传递的数据"></a>mockjs获取前端传递的数据</h1><pre><code>axios(&#123;
      method: &quot;get&quot;,
      url: &quot;/getGoods&quot;,
      data: &#123;
        id:2
      &#125;
    &#125;).then(data =&gt; &#123;
      //成功的回调函数，返回的是增加的数据
      console.log(data.data.data);
      this.url = data.data.data[0].goodsImg
    &#125;);
  &#125;

  Mock.mock(&quot;/getGoods&quot;, &quot;get&quot;, (config) =&gt; &#123;
  console.log(config);
  return data;
&#125;)
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/react-router-dom/" title="react-router-dom" itemprop="url">react-router-dom</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T07:01:00.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="React路由介绍"><a href="#React路由介绍" class="headerlink" title="React路由介绍"></a>React路由介绍</h1><p>现代的前端应用大多是SPA（单页面应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器的压力更小，为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。</p>
<ul>
<li>前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面）</li>
<li>前端路由是一套映射规则，在React中，是URL路径与组建的对应关系</li>
<li>使用React路由简单来说，就是配置路径和组件（配对）</li>
</ul>
<h1 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h1><ol>
<li>安装：yarn add react-router-dom</li>
<li>导入路由的核心组件：Router/Routes/Route/Link<br> import {BrowerRouter as Router, Routes, Route, Link} from ‘react-router-dom’</li>
<li>使用Router组件包裹整个应用</li>
</ol>
<p>4.使用Link组件作为导航菜单（路由入口）<br><code>&lt;Link to=&quot;\first&quot;&gt;页面&lt;/Link&gt; </code><br>5.使用Route组件配置路由规则和要展示的组件（路由出口）<br>    const First = ()=&gt;<p>页面一的页面内容</p><br>    <Router><br>            <div className="App"><br>                <Link to="\first"><br>                    页面一<br>                </Link><br>                <Routes><br>                &lt;Route path=”/first” element={<First/>}&gt;</Route><br>            </Routes><br>         </div><br>    </Router></p>
<h2 id="常用组件说明"><a href="#常用组件说明" class="headerlink" title="常用组件说明"></a>常用组件说明</h2><ul>
<li><p>Router组件：包裹整个应用，一个React应用只需要使用一次</p>
</li>
<li><p>两种常用的Router：HashRouter和BrowserRouter</p>
</li>
<li><p>HashRouter：使用URL的哈希值实现（localhost:3000/#/first）</p>
</li>
<li><p>（推荐）BrowserRouter：使用H5的history API实现（localhost:3000/first）</p>
</li>
<li><p>Link组件：用于指定导航链接（a标签）</p>
<p>  //to属性：浏览器地址栏中的pathname（location.pathname）</p>
  <Link to="/first">页面一</Link></li>
<li><p>Route组件：指定路由展示组件相关信息</p>
<p>  //path属性：展示的组件<br>  //element属性：展示的内容<br>  //Route组件写在哪，渲染的组件就展示在哪<br>  &lt;Route path=”/first” element={<First/>}&gt;</Route></p>
</li>
</ul>
<h1 id="路由的执行过程"><a href="#路由的执行过程" class="headerlink" title="路由的执行过程"></a>路由的执行过程</h1><ol>
<li>点击Link组件（a标签），修改了浏览器地址栏中的url。</li>
<li>React路由监听到地址栏url的变化。</li>
<li>React路由内部遍历所有的Route组件，使用路由规则（path）与pathname进行匹配。</li>
<li>当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容。</li>
</ol>
<h1 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h1><p>默认路由：表示进入页面时就会匹配的路由<br>默认路由path为：/</p>
<pre><code>&lt;Route path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&lt;/Route&gt;
</code></pre>
<h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><h2 id="模糊匹配模式"><a href="#模糊匹配模式" class="headerlink" title="模糊匹配模式"></a>模糊匹配模式</h2><p>当Link组件的to属性值为”/login”时，默认路由也会被匹配成功。<br>默认情况下，React路由是模糊匹配方式，模糊匹配规则：只要pathname以path开头就会匹配成功</p>
<pre><code>&lt;Link to=&quot;/login&quot;&gt;登录页面&lt;/Link&gt;
&lt;Route path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&gt;   匹配成功

//path代表Route组件的path属性
//pathname代表Link组件的to属性（也就是location.pathname）
</code></pre>
<h2 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h2><p>给Route组件添加exact属性，让其变为精确匹配模式。精确匹配：只有当path和pathname完全匹配时才会展示该路由</p>
<pre><code>//此时，该组件只能匹配pathname=&quot;/&quot;这一种情况
&lt;Route exact path=&quot;/&quot; element=&#123;&lt;Home/&gt;&#125;&gt;&lt;/Route&gt;
</code></pre>
<p>推荐：给默认路由添加exact属性。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/23/bootstrap/" title="bootstrap" itemprop="url">bootstrap</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-02-23T06:58:58.000Z" itemprop="datePublished"> Published 2022-02-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;Bootstrap 实例 - 响应式的列重置&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

   &lt;div class = &quot;container&quot;&gt;&lt;!--      .container 类用于固定宽度并支持响应式布局的容器--&gt;
      123
   &lt;/div&gt;
   &lt;div class=&quot;container-fluid&quot;&gt; &lt;!--      .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。--&gt;
      456
   &lt;/div&gt;
   &lt;table class=&quot;table table-bordered&quot;&gt;&lt;!--      添加 .table-bordered 类为表格和其中的每个单元格增加边框。--&gt;
      &lt;tr&gt;
         &lt;td&gt;姓名&lt;/td&gt;
         &lt;td&gt;科目&lt;/td&gt;
         &lt;td&gt;成绩&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;夏明&lt;/td&gt;
         &lt;td&gt;数学&lt;/td&gt;
         &lt;td&gt;149&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;徐雪&lt;/td&gt;
         &lt;td&gt;英语&lt;/td&gt;
         &lt;td&gt;139&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>要使用boostrap，下面这些代码是必须要添加上的：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
&lt;/div&gt;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/29/react-redux/" title="react-redux" itemprop="url">react-redux</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-29T02:46:01.000Z" itemprop="datePublished"> Published 2022-01-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux的组成"><a href="#redux的组成" class="headerlink" title="redux的组成"></a>redux的组成</h2><h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state-状态"></a>state-状态</h3><p>就是我们传递的数据，我们在用React开发项目的时候，大致可以把State分成三类：</p>
<ul>
<li><p>DomainDate：可以理解为服务器端的数据，比如：获取用户的信息，商品的列表等等</p>
</li>
<li><p>UI State：决定当前UI展示的状态，比如：弹框的显示隐藏，受控组件等等</p>
</li>
<li><p>App State：App级别的状态，比如：当前是否请求loading，当前路由信息等可能被多个和组件去使用到的状态。</p>
</li>
</ul>
<h3 id="Action-事件"><a href="#Action-事件" class="headerlink" title="Action-事件"></a>Action-事件</h3><p>Action是把数据从应用传到store的载体，它是store数据的唯一来源，一般来说，我们可以通过store.dispatch()将action传递给store</p>
<p><strong>Action特点：</strong></p>
<ul>
<li>Action的本质就是一个javascript的普通对象</li>
<li>Action对象内部必须要有一个<strong>type</strong>属性来表示要执行的动作</li>
<li>多数情况下，这个<strong>type</strong>会被定义成字符串常量</li>
<li>除了<strong>type</strong>之外，action的结构随意进行定义</li>
<li>而我们在项目中，更多的喜欢用<strong>action</strong>创建函数（就是创建action的地方）</li>
<li><strong>只是描述了有事情要发生，并没有描述如何去更新state</strong></li>
</ul>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p><strong>reducer</strong>本质就是一个函数，它用来<strong>响应</strong>发送过来的<strong>actions</strong>，然后经过处理，把<strong>state</strong>发送给<strong>Store</strong>的</p>
<p><strong>注意：</strong>在reducer函数中，需要return返回值，这样Store才能接收到数据，函数会接收两个参数，第一个参数是初始化的state，第二个参数是action</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store就是把action与reducer联系到一起的对象</p>
<p>主要职责：</p>
<ul>
<li>维持应用的state</li>
<li>提供getState()方法获取state</li>
<li>提供dispatch()方法发送action</li>
<li>通过subscribe()来注册监听</li>
<li>通过subscribe()返回值注销监听</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>构建react项目</p>
<p>  <code>npx create-react-app redux-demo</code></p>
</li>
<li><p>删除多余的文件<br>(留下index.css,index.js,App.js)</p>
</li>
<li><p>在pages目录下创建Home组件</p>
</li>
<li><p>编写一个简单的结构样式</p>
<p>  <code>&lt;button&gt;发送一个action&lt;/button&gt;</code></p>
</li>
<li><p>在App.js中引入这个组件</p>
</li>
<li><p>安装redux</p>
<p>  <code>yarn add redux</code></p>
<h2 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h2></li>
<li><p>在根目录下创建一个文件夹action</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建Action</p>
<p>  const senAction = ()=&gt;{…};</p>
</li>
<li><p>在action创建函数里面利用return，返回一个action对象，注意需要携带type属性</p>
<p>  const sendAction=()=&gt;{return{type:”send_action”, value:”发送了一个action”}}</p>
</li>
<li><p>把这个action创建函数进行导出</p>
<p>  module.exports = {sendAction}</p>
<h2 id="创建一个Reducer"><a href="#创建一个Reducer" class="headerlink" title="创建一个Reducer"></a>创建一个Reducer</h2></li>
<li><p>在根目录下创建一个reducer</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建reducer，注意reducer要接收两个参数</p>
<p>  const rootReducer = (state, action) =&gt;{…};</p>
</li>
<li><p>第一个参数是默认状态，我们可以定义一个初始化的state，然后进行赋值</p>
<p>  const initState = {value:”默认值”}<br>  const rootReducer = (state = initState, action)=&gt;{…};</p>
</li>
<li><p>在函数里面判断第二个参数action的type是否是我们发送的</p>
</li>
<li><p>如果是的话，我们可以通过return返回新的state</p>
</li>
<li><p>把reducer进行导出</p>
</li>
</ul>
<h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2><ul>
<li><p>在根目录下创建一个文件夹store</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建store，注意createStore函数里面第一个参数接收的是reducer</p>
<pre><code>  import &#123;createStore&#125; from &quot;redux&quot;;
  const store = createStore&#123;reducer&#125;;
</code></pre>
</li>
<li><p>我们需要导入刚刚创建的reducer，然后设置到函数里面去</p>
</li>
<li><p>createStore的返回值就是我们构建好的store，然后进行导出</p>
</li>
</ul>
<h1 id="react-redux基本使用"><a href="#react-redux基本使用" class="headerlink" title="react-redux基本使用"></a>react-redux基本使用</h1><ul>
<li><p>在app.js中导入Provider组件</p>
<p>  <code>import &#123;Provider&#125; from &#39;react-redux&#39;</code></p>
</li>
<li><p>利用Provider组件将我们整个结构进行包裹，并且传递store</p>
<pre><code>  function App()&#123;
      return (&lt;Provider store = &#123;store&#125;&gt;&lt;/Provider)
  &#125;
</code></pre>
</li>
<li><p>导入connect方法</p>
<p>  <code>import &#123;connect&#125; from &quot;react-redux&quot;;</code></p>
</li>
<li><p>调用connect方法</p>
<p>  <code>connect(...)(Component)</code></p>
</li>
</ul>
<p>connect参数说明：</p>
<ul>
<li><p><strong>mapStateToProps(state, ownProps) 这个函数允许我们将store中的数据作为props绑定到组建上</strong></p>
</li>
<li><p><strong>mapDisPatchToProps(dispatch, ownProps) 将action作为props绑定到我们自己的函数中，dispatch就是store.dispatch(), ownProps自己的props</strong></p>
</li>
<li><p>mergeProps(stateProps, dispatchProps, ownProps) 不管是stateProps还是dispatchProps，都需要和ownProps merge之后才会被赋给我们的组件，通常情况下，可以不传这个参数，connect就会使用Object.assign替代该方法</p>
</li>
</ul>
<h2 id="利用connect方法让我们组件与store关联"><a href="#利用connect方法让我们组件与store关联" class="headerlink" title="利用connect方法让我们组件与store关联"></a>利用connect方法让我们组件与store关联</h2><ul>
<li><p>在组件ComA和ComB，分别导入connect方法</p>
<p>  import {connect} from ‘react-redux’</p>
</li>
<li><p>利用connect()方法来对我们组件进行加强，并且导出</p>
<p>  export default connect(mapStateToProps, mapDisPatchToProps)(Home)</p>
</li>
<li><p>组件ComA属于发送方，所以要实现第二个参数</p>
</li>
<li><p>组件ComB属于接收方，所以要实现第一个参数</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/09/es6/" title="es6" itemprop="url">es6</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-09T07:26:41.000Z" itemprop="datePublished"> Published 2022-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#let和const#</p>
<p><strong>let 声明的变量只在 let 命令所在的代码块内有效。</strong></p>
<p><strong>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</strong></p>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>基本用法:</p>
<pre><code>&#123;
  let a = 0;
  a   // 0
&#125;
a   // 报错 ReferenceError: a is not defined
</code></pre>
<p>代码块内有效</p>
<p><em>let 是在代码块内有效，var 是在全局范围内有效:</em></p>
<pre><code>&#123;
  let a = 0;
  var b = 1;
&#125;
a  // ReferenceError: a is not defined
b  // 1
</code></pre>
<p><em>不能重复声明，let 只能声明一次 var 可以声明多次:</em></p>
<pre><code>let a = 1;
let a = 2;
var b = 3;
var b = 4;
a  // Identifier &#39;a&#39; has already been declared
b  // 4
</code></pre>
<p>for 循环计数器很适合用 let</p>
<pre><code>for (var i = 0; i &lt; 10; i++) &#123;
  setTimeout(function()&#123;
    console.log(i);
  &#125;)
&#125;
// 输出十个 10
for (let j = 0; j &lt; 10; j++) &#123;
  setTimeout(function()&#123;
    console.log(j);
  &#125;)
&#125;
// 输出 0123456789
</code></pre>
<p>变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。</p>
<p>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。<br>不存在变量提升</p>
<p>let 不存在变量提升，var 会变量提升:</p>
<pre><code>console.log(a);  //ReferenceError: a is not defined
let a = &quot;apple&quot;;

console.log(b);  //undefined
var b = &quot;banana&quot;;
</code></pre>
<p>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。</p>
<p>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。</p>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p><strong>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</strong></p>
<p>基本用法:</p>
<pre><code>const PI = &quot;3.1415926&quot;;
PI  // 3.1415926

const MY_AGE;  // SyntaxError: Missing initializer in const declaration    
</code></pre>
<p>暂时性死区:</p>
<pre><code>var PI = &quot;a&quot;;
if(true)&#123;
  console.log(PI);  // ReferenceError: PI is not defined
  const PI = &quot;3.1415926&quot;;
&#125;
</code></pre>
<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>
<p><strong>注意要点</strong></p>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<p>#解构赋值#</p>
<p>解构赋值是对赋值运算符的扩展。<strong>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</strong></p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。<br>解构模型</p>
<p>在解构中，有下面两部分参与：<strong>解构的源，解构赋值表达式的右边部分；解构的目标，解构赋值表达式的左边部分。</strong></p>
<h2 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h2><p>基本</p>
<pre><code>let [a, b, c] = [1, 2, 3];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可嵌套</p>
<pre><code>let [a, [[b], c]] = [1, [[2], 3]];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可忽略</p>
<pre><code>let [a, , b] = [1, 2, 3];
// a = 1
// b = 3
</code></pre>
<p>不完全解构</p>
<pre><code>let [a = 1, b] = []; // a = 1, b = undefined
</code></pre>
<p>剩余运算符</p>
<pre><code>let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
</code></pre>
<p>###字符串等###</p>
<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<pre><code>let [a, b, c, d, e] = &#39;hello&#39;;
// a = &#39;h&#39;
// b = &#39;e&#39;
// c = &#39;l&#39;
// d = &#39;l&#39;
// e = &#39;o&#39;
</code></pre>
<p>解构默认值</p>
<pre><code>let [a = 2] = [undefined]; // a = 2
</code></pre>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<pre><code>let [a = 3, b = a] = [];     // a = 3, b = 3
let [a = 3, b = a] = [1];    // a = 1, b = 1
let [a = 3, b = a] = [1, 2]; // a = 1, b = 2
</code></pre>
<p>a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3<br>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1<br>a 与 b 正常解构赋值，匹配结果：a = 1，b = 2 </p>
<h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3><p>基本</p>
<pre><code>let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
// foo = &#39;aaa&#39;
// bar = &#39;bbb&#39;
 
let &#123; baz : foo &#125; = &#123; baz : &#39;ddd&#39; &#125;;
// foo = &#39;ddd&#39;
</code></pre>
<p>可嵌套可忽略</p>
<pre><code>let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123; y &#125;] &#125; = obj;
// x = &#39;hello&#39;
// y = &#39;world&#39;
let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123;  &#125;] &#125; = obj;
// x = &#39;hello&#39;
</code></pre>
<p>不完全解构</p>
<pre><code>let obj = &#123;p: [&#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [&#123; y &#125;, x ] &#125; = obj;
// x = undefined
// y = &#39;world&#39;
</code></pre>
<p>剩余运算符</p>
<pre><code>let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;;
// a = 10
// b = 20
// rest = &#123;c: 30, d: 40&#125;
</code></pre>
<p>解构默认值</p>
<pre><code>let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;
// a = 3; b = 5;
let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;
// aa = 3; bb = 5;
</code></pre>
<p>#ES6 Map与Set#</p>
<p>##Map 对象##</p>
<p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>Maps 和 Objects 的区别：</p>
<pre><code>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。
</code></pre>
<p>##Map 中的 key##</p>
<pre><code>var myMap = new Map();
var keyString = &quot;a string&quot;; 
 
myMap.set(keyString, &quot;和键&#39;a string&#39;关联的值&quot;);
 
myMap.get(keyString);    // &quot;和键&#39;a string&#39;关联的值&quot;
myMap.get(&quot;a string&quot;);   // &quot;和键&#39;a string&#39;关联的值&quot;
                         // 因为 keyString === &#39;a string&#39;
</code></pre>
<p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p>
<p>###Map 的迭代###</p>
<p>对 Map 进行遍历，以下两个最高级。<br><strong>for…of</strong></p>
<pre><code>var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);

// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

for (var [key, value] of myMap) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
for (var [key, value] of myMap.entries()) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */

// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;

for (var key of myMap.keys()) &#123;
  console.log(key);
&#125;
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */

// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;
for (var value of myMap.values()) &#123;
  console.log(value);
&#125;
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */

    forEach()
    var myMap = new Map();
    myMap.set(0, &quot;zero&quot;);
    myMap.set(1, &quot;one&quot;);
 
// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

    myMap.forEach(function(value, key) &#123;
      console.log(key + &quot; = &quot; + value);
    &#125;, myMap)
</code></pre>
<p>###Map 对象的操作###</p>
<p>####Map 与 Array的转换####</p>
<pre><code>var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];

// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象

var myMap = new Map(kvArray);

// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组

var outArray = Array.from(myMap);
</code></pre>
<p>####Map 的克隆####</p>
<pre><code>var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);
var myMap2 = new Map(myMap1);

console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。
</code></pre>
<h4 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h4><pre><code>var first = new Map([[1, &#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;],]);
var second = new Map([[1, &#39;uno&#39;], [2, &#39;dos&#39;]]);

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three

var merged = new Map([...first, ...second]);
</code></pre>
<p>##Set 对象##</p>
<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>###Set 中的特殊值###</p>
<p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<pre><code>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
undefined 与 undefined 是恒等的，所以不重复；
NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。
</code></pre>
<p>代码</p>
<pre><code>let mySet = new Set();
 
mySet.add(1); // Set(1) &#123;1&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125; 这里体现了值的唯一性
mySet.add(&quot;some text&quot;); 
// Set(3) &#123;1, 5, &quot;some text&quot;&#125; 这里体现了类型的多样性
var o = &#123;a: 1, b: 2&#125;; 
mySet.add(o);
mySet.add(&#123;a: 1, b: 2&#125;); 
// Set(5) &#123;1, 5, &quot;some text&quot;, &#123;…&#125;, &#123;…&#125;&#125; 
</code></pre>
<p>// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储<br>类型转换</p>
<p>Array</p>
<pre><code>// Array 转 Set
var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);
// 用...操作符，将 Set 转 Array
var myArray = [...mySet];
</code></pre>
<p>String</p>
<pre><code>// String 转 Set
var mySet = new Set(&#39;hello&#39;);  // Set(4) &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;&#125;
// 注：Set 中 toString 方法是不能将 Set 转换成 String
</code></pre>
<p>###Set 对象作用###</p>
<p>####数组去重####</p>
<pre><code>var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]
</code></pre>
<p>####并集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // &#123;1, 2, 3, 4&#125;
</code></pre>
<p>####交集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x =&gt; b.has(x))); // &#123;2, 3&#125;
</code></pre>
<p>####差集####</p>
<pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x =&gt; !b.has(x))); // &#123;1&#125;
</code></pre>
<p>#字符串拓展方法#</p>
<p>##子串的识别##</p>
<p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p>
<ul>
<li><p><strong>includes()：返回布尔值，判断是否找到参数字符串。</strong></p>
</li>
<li><p><strong>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。</strong></p>
</li>
<li><p><strong>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。</strong></p>
</li>
</ul>
<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>
<pre><code>let string = &quot;apple,banana,orange&quot;;
string.includes(&quot;banana&quot;);     // true
string.startsWith(&quot;apple&quot;);    // true
string.endsWith(&quot;apple&quot;);      // false
string.startsWith(&quot;banana&quot;,6)  // true
</code></pre>
<p><strong>注意点</strong>：</p>
<ul>
<li><p>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</p>
</li>
<li><p>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/09/刷题经验/" title="刷题经验" itemprop="url">刷题经验</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-09T01:53:11.000Z" itemprop="datePublished"> Published 2022-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="链表求中点-："><a href="#链表求中点-：" class="headerlink" title="链表求中点 #："></a>链表求中点 #：</h1><pre><code>var slow = head, fast = head.next;
while(fast!=null &amp;&amp; fast.next!=null)&#123;
    slow = slow.next;
    fast = fast.next.next;
&#125;
</code></pre>
<h1 id="围成圆，提取的位置不能相邻-："><a href="#围成圆，提取的位置不能相邻-：" class="headerlink" title="围成圆，提取的位置不能相邻 #："></a>围成圆，提取的位置不能相邻 #：</h1><p>（采用枚举法）<br>两种情况：1.有头没尾；2.没头有尾</p>
<h1 id="三数之和："><a href="#三数之和：" class="headerlink" title="三数之和：#"></a>三数之和：#</h1><pre><code>var threeSum = function(nums) &#123;
    const len = nums.length;
    if(len &lt; 3) return [];
    nums.sort((a, b) =&gt; a - b);
    const resSet = new Set();
    for(let i = 0; i &lt; len - 2; i++) &#123;
        if(nums[i] &gt; 0) break;
        let l = i + 1, r = len - 1;
        while(l &lt; r) &#123;
            const sum = nums[i] + nums[l] + nums[r];
            if(sum &lt; 0) &#123; l++; continue &#125;;
            if(sum &gt; 0) &#123; r--; continue &#125;;
            resSet.add(`$&#123;nums[i]&#125;,$&#123;nums[l]&#125;,$&#123;nums[r]&#125;`);
            l++;
            r--;
        &#125;
    &#125;
    return Array.from(resSet).map(i =&gt; i.split(&quot;,&quot;));
&#125;;
</code></pre>
<h1 id="不需要额外空间的方法，就往位运算上想"><a href="#不需要额外空间的方法，就往位运算上想" class="headerlink" title="不需要额外空间的方法，就往位运算上想"></a>不需要额外空间的方法，就往位运算上想</h1><h1 id="map的使用："><a href="#map的使用：" class="headerlink" title="map的使用："></a>map的使用：</h1><pre><code>var majorityElement = function(nums) &#123;
    if(nums.length &lt; 3)&#123;
        return nums[0];
    &#125;

    var map = new Map()
    var count = Math.floor(nums.length/2);
    for(let i = 0;i&lt;nums.length;i++)&#123;
        if(map.get(nums[i]))&#123;
            map.set(nums[i], map.get(nums[i]) + 1)
            //修改value值
        &#125;
        else&#123;
            map.set(nums[i], 1)
        &#125;
    &#125;
    console.log(count)
    for (let key of map.keys()) &#123;
        if(map.get(key)&gt;count)&#123;
            //获取value的正确写法
            return key;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="子数组最大和："><a href="#子数组最大和：" class="headerlink" title="子数组最大和："></a>子数组最大和：</h1><pre><code>const maxSubArray = nums =&gt; &#123;
    // 数组长度，dp初始化
    const [len, dp] = [nums.length, [nums[0]]];
    // 最大值初始化为dp[0]
    let max = dp[0];
    for (let i = 1; i &lt; len; i++) &#123;
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        // 更新最大值
        max = Math.max(max, dp[i]);
    &#125;
    return max;
&#125;;
</code></pre>
<p>连续的思想包含在</p>
<pre><code>Math.max(dp[i - 1] + nums[i], nums[i])
</code></pre>
<h1 id="环形数组："><a href="#环形数组：" class="headerlink" title="环形数组："></a>环形数组：</h1><p>两种情况：一种是最大和子数组在数组内；一种是最大子数组在两边，这个时候除开最大子数组，中间的留下的就是最小子数组。</p>
<pre><code>var total = 0, maxSum = nums[0], curMax = 0, minSum = nums[0], curMin = 0;
for (let a of nums) &#123;
    curMax = Math.max(curMax + a, a);
    maxSum = Math.max(maxSum, curMax);
    curMin = Math.min(curMin + a, a);
    minSum = Math.min(minSum, curMin);
    total += a;
&#125;
return maxSum &gt; 0 ? Math.max(maxSum, total - minSum) : maxSum;
</code></pre>
<p>子数组最大积</p>
<pre><code>var maxProduct = function(nums) &#123;
 var a=1;  
var max=nums[0];

for(var num of nums)&#123;
    a=a*num;
    if(max&lt;a)max=a;
    if(num==0)a=1;

&#125;
a=1;
for(var i=nums.length-1;i&gt;=0;i--)&#123;
    a=a*nums[i];
    if(max&lt;a)max=a;
    if(nums[i]==0)a=1;
&#125;  
return max;
&#125;;
</code></pre>
<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><pre><code>ingredients.forEach(function(a)&#123;return new Set(a)&#125;)
[...new Set(supplies)]
</code></pre>
<p>不断重复的过程中添加新的元素，循环推出条件：没有新元素加入则退出。下面这个代码的循环推出条件值得参考。</p>
<pre><code>var findAllRecipes = function(recipes, ingredients, supplies) &#123;
    var intersect, result = [], valid, interact;
    ingredients.forEach(function(a)&#123;return new Set(a)&#125;)
    supplies.forEach(function(a)&#123;return new Set(a)&#125;)
    while(true)&#123;
        valid = false;
        for(let i = 0;i&lt;recipes.length;i++)&#123;
            if(result.indexOf(recipes[i])!=-1)&#123;
                continue
            &#125;
            interact = new Set(ingredients[i].filter(x =&gt; supplies.indexOf(x)!=-1));
            if([...interact].length == ingredients[i].length)&#123;
                valid = true;
                result.push(recipes[i]);
                supplies.push(recipes[i]);
            &#125;
        &#125;
        if (valid == false)&#123;
            break;
        &#125;
    &#125;
    return result;
&#125;;
</code></pre>
<h1 id="数组、字符串、整数互相转换："><a href="#数组、字符串、整数互相转换：" class="headerlink" title="数组、字符串、整数互相转换："></a>数组、字符串、整数互相转换：</h1><ul>
<li><p>split() 方法，功能：将字符串按某个字符切割成若干个字符串，并以数组形式返回，<code>arr.split(&quot;&quot;)</code></p>
</li>
<li><p>join() 方法 功能：将数组元素用某个字符连接成字符串， <code>arr.join(&quot;&quot;)</code></p>
</li>
<li><p>字符串转换成整数：parseInt，<code>parseInt(&#39;123&#39;)</code></p>
</li>
<li><p>将数值转换成字符串，<code>&#39;123&#39;.toString()</code></p>
</li>
</ul>
<h1 id="注意：1-lt-a-lt-2这种写法是错误的，应该改成1-lt-a-amp-amp-a-lt-2"><a href="#注意：1-lt-a-lt-2这种写法是错误的，应该改成1-lt-a-amp-amp-a-lt-2" class="headerlink" title="注意：1&lt;a&lt;=2这种写法是错误的，应该改成1&lt;a &amp;&amp; a&lt;=2"></a>注意：<code>1&lt;a&lt;=2</code>这种写法是错误的，应该改成<code>1&lt;a &amp;&amp; a&lt;=2</code></h1><h1 id="KMP算法："><a href="#KMP算法：" class="headerlink" title="KMP算法："></a>KMP算法：</h1><pre><code>function KMPNext(str)&#123;
    var next = [0];
    for(var i = 1, j = 0;i&lt;str.length;i++)&#123;
        while(j&gt;0 &amp;&amp; str[i]!=str[j])&#123;
            j = next[j-1];//这里其实是与前面的相比较，比如ABCDAB，B这个数的部分匹配值其实是与前面的ABCD中B相比较，如果相同则加一，不然归零。
            console.log(j);

        &#125;
        if(str[i] == str[j])&#123;
            j++;
        &#125;
        next[i] = j;

    &#125;
    return next;
&#125;
function KMPSearch(str1, str2)&#123;
    var next = KMPNext(str2);
    for(var i = 0, j = 0;i&lt;str1.length;i++)&#123;
        if(str1[i] == str2[j])&#123;
            j++;
        &#125;
        else&#123;
            i = i-(j-next[j]);
            j = 0;
        &#125;
        if(j == str2.length)&#123;
            return i-j+1;

        &#125;
    &#125;
    return -1;

&#125;
var str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;, str2 = &quot;ABCDABD&quot;;
console.log(KMPSearch(str1, str2));
</code></pre>
<h1 id="map删除某个key值："><a href="#map删除某个key值：" class="headerlink" title="map删除某个key值："></a>map删除某个key值：</h1><pre><code>map.delete(key)
map.keys()
map.values()
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/06/php/" title="php" itemprop="url">php</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-06T11:43:01.000Z" itemprop="datePublished"> Published 2022-01-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="php变量"><a href="#php变量" class="headerlink" title="php变量"></a>php变量</h1><h2 id="PHP-变量规则"><a href="#PHP-变量规则" class="headerlink" title="PHP 变量规则"></a>PHP 变量规则</h2><ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）</li>
<li>变量名不能包含空格</li>
<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li>
</ul>
<pre><code>&lt;?php
    $txt=&quot;Hello world!&quot;;
    $x=5;
    $y=10.5;
    echo $txt.$x.$y
?&gt;
</code></pre>
<h2 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h2><p>变量的作用域是脚本中变量可被引用/使用的部分。</p>
<p>PHP 有四种不同的变量作用域：</p>
<ul>
<li><p>local</p>
</li>
<li><p>global</p>
</li>
<li><p>static</p>
</li>
<li><p>parameter</p>
</li>
</ul>
<h3 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h3><pre><code> &lt;?php
    $x=5; // 全局变量
    
    function myTest()
    &#123;
        $y=10; // 局部变量
        echo &quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;;
        echo &quot;变量 x 为: $x&quot;;
        echo &quot;&lt;br&gt;&quot;;
        echo &quot;变量 y 为: $y&quot;;
    &#125; 
    
    myTest();
    
    echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;
    echo &quot;变量 x 为: $x&quot;;
    echo &quot;&lt;br&gt;&quot;;
    echo &quot;变量 y 为: $y&quot;;
?&gt; 
</code></pre>
<p><strong>global</strong> 关键字用于函数内访问全局变量。在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：</p>
<pre><code>&lt;?php
    $x=5;
    $y=10;
     
    function myTest()
    &#123;
        global $x,$y;
        $y=$x+$y;
    &#125;
     
    myTest();
    echo $y; // 输出 15
?&gt;
</code></pre>
<h1 id="PHP-echo-语句"><a href="#PHP-echo-语句" class="headerlink" title="PHP echo 语句"></a>PHP echo 语句</h1><p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p>
<pre><code>&lt;?php
    echo &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;
    echo &quot;Hello world!&lt;br&gt;&quot;;
    echo &quot;我要学 PHP!&lt;br&gt;&quot;;
    echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;
?&gt;
</code></pre>
<h1 id="php数据类型"><a href="#php数据类型" class="headerlink" title="php数据类型"></a>php数据类型</h1><ul>
<li><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p>
</li>
<li><p>PHP 字符串：一个字符串是一串字符的序列，就像 “Hello world!”。你可以将任何文本放在单引号和双引号中。</p>
</li>
<li><p>PHP 布尔型：布尔型可以是 TRUE 或 FALSE。</p>
</li>
<li><p>PHP 数组：数组可以在一个变量中存储多个值。</p>
</li>
<li><p>PHP 对象：对象数据类型也可以用于存储数据。在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：</p>
<pre><code>  &lt;?php
      class Car
      &#123;
        var $color;
        function __construct($color=&quot;green&quot;) &#123;
          $this-&gt;color = $color;
        &#125;
        function what_color() &#123;
          return $this-&gt;color;
        &#125;
      &#125;
  ?&gt;
</code></pre>
</li>
</ul>
<p>以上实例中php关键字this就是指向当前对象实例的指针，不指向任何其他对象或类。</p>
<ul>
<li><p>PHP NULL 值:NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。可以通过设置变量值为 NULL 来清空变量数据：</p>
<pre><code>  &lt;?php
      $x=&quot;Hello world!&quot;;
      $x=null;
      var_dump($x);
  ?&gt;
</code></pre>
</li>
</ul>
<h1 id="PHP-类定义"><a href="#PHP-类定义" class="headerlink" title="PHP 类定义"></a>PHP 类定义</h1><p>PHP 定义类通常语法格式如下：</p>
<pre><code>&lt;?php
class phpClass &#123;
  var $var1;
  var $var2 = &quot;constant string&quot;;
  
  function myfunc ($arg1, $arg2) &#123;
     [..]
  &#125;
  [..]
&#125;
?&gt;
</code></pre>
<p>解析如下：</p>
<ul>
<li><p>类使用 class 关键字后加上类名定义。</p>
</li>
<li><p>类名后的一对大括号({})内可以定义变量和方法。</p>
</li>
<li><p>类的变量使用 var 来声明, 变量也可以初始化值。</p>
</li>
<li><p>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</p>
</li>
</ul>
<pre><code>&lt;?php
    class Site &#123;
      /* 成员变量 */
      var $url;
      var $title;
      
      /* 成员函数 */
      function setUrl($par)&#123;
         $this-&gt;url = $par;
      &#125;
      
      function getUrl()&#123;
         echo $this-&gt;url . PHP_EOL;
      &#125;
      
      function setTitle($par)&#123;
         $this-&gt;title = $par;
      &#125;
      
      function getTitle()&#123;
         echo $this-&gt;title . PHP_EOL;
      &#125;
    &#125;
?&gt;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/06/KMP-动态规划-贪心算法…-Prime算法/" title="KMP&amp;动态规划&amp;贪心算法…&amp;Prime算法" itemprop="url">KMP&amp;动态规划&amp;贪心算法…&amp;Prime算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-06T05:43:53.000Z" itemprop="datePublished"> Published 2022-01-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>问题</strong></p>
<p>KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。</p>
<p><strong>代码实现</strong></p>
<pre><code>function KMPSearch(str1, str2, next)&#123;
    for(var i = 0, j = 0;i&lt;str1.length;i++)&#123;
        while(j&gt;0 &amp;&amp; str1[i] != str2[j])&#123;
            j = next[j-1];
        &#125;
        if(str1[i] == str2[j])&#123;
            j++;
        &#125;
        if(j == str2.length)&#123;
            return i-j+1;
        &#125;
    &#125;
    return -1;
&#125;
function KMPNext(dest)&#123;
    var next = new Array(dest.length);
    for(var i = 0;i&lt;dest.length;i++)&#123;
        dest[i] = 0;
    &#125;
    for(var i = 0, j = 0;i&lt;dest.length;i++)&#123;
        while(j&gt;0 &amp;&amp; dest[i]!=dest[j])&#123;
            j = next[j-1];
        &#125;
        if(dest[i] == dest[j])&#123;
            j++;
        &#125;
        next[i] = j;
    &#125;
    return next;
&#125;
</code></pre>
<p>#动态规划#<br><strong>背包问题</strong></p>
<p>背包问题：假如目前有三种物品：吉他、音响、电脑，他们的价值分别是1000、2000、2500，重量分别是1磅、3磅、2磅，背包的容量是固定值4磅，现在要把几种物品放进背包中使得在不超重的前提下背包的价值达到最大。<br>**代码实现    **</p>
<pre><code>function dynamic_planning()&#123;
    var val = [1000, 3000, 2500];
    var w = [1, 3, 2];
    var sum = 4;
    var v = new Array(w.length);
    for(var i = 0;i&lt;v.length;i++)&#123;
        v[i] = new Array(sum);
    &#125;
    for(i = 0;i&lt;v.length;i++)&#123;
        for(var j = 0;j&lt;sum;j++)&#123;
            v[i][j] = 0;
        &#125;
    &#125;
    for(i = 0;i&lt;v.length;i++)&#123;
        for(j = 0;j&lt;sum;j++)&#123;
            if(w[i-1]&gt;j)&#123;
                v[i][j] = v[i-1][j];
            &#125;
            else&#123;
                v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
            &#125;
        &#125;
    &#125;
        &#125;
</code></pre>
<h1 id="贪心算法（最佳应用：集合覆盖问题）"><a href="#贪心算法（最佳应用：集合覆盖问题）" class="headerlink" title="贪心算法（最佳应用：集合覆盖问题）"></a>贪心算法（最佳应用：集合覆盖问题）</h1><p><strong>概念：</strong>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。</p>
<p>问题描述：假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号？</p>
<table border="1px" cellspacing="0px" cellpadding="8px" >
    <tr height = "27px" align = "center">
        <td width = "80px">广播台</td>
        <td width = "120px">覆盖地区</td>
    </tr>
    <tr height = "27px" align = "center">
        <td>K1</td>
        <td >"北京","上海","天津"</td>
    </tr>
    <tr height = "27px" align = "center">
        <td>K2</td>
        <td colspan="4">"广州","北京","深圳"</td>
    </tr>
    <tr height = "27px" align = "center">
    <td>K3</td>
    <td>"成都","上海","杭州"</td>
    </tr>
    <tr height = "27px" align = "center">
    <td>K4</td>
    <td>"上海","天津"</td>
    </tr>
    <tr height = "27px" align = "center">
    <td>K5</td>
    <td>"杭州","大连"</td>
    </tr>
</table>

<p><strong>算法思路：</strong></p>
<p>1). 遍历所有的广播电台，<strong>找到一个覆盖了最多未覆盖的地区的电台</strong>（此电台可能包含一些已覆盖的地区，但没关系）</p>
<p>2). 将这个电台加入到一个集合中（比如ArrayList），想办法把电台覆盖的地区在下次比较时去掉。</p>
<p>3). <strong>重复第一步</strong>，直到覆盖了全部的地区。</p>
<pre><code>function greedy(broadcast, allAreas)&#123;
    var selects = [];
    //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
    var tempSet = [];
    //定义maxKey，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
    //如果maxKey不为null， 则会加入到selects中
    var maxKey = null;
    while(allAreas.length != 0)&#123;
        //如果allAreas不为0，则表示还没有覆盖到所有的地区
        //遍历broadcast，取出对应key
        maxKey = null;
        for(let item of broadcast.keys())&#123;
            let intersect = [...new Set([...broadcast.get(item)].filter(x =&gt; allAreas.indexOf(x)!=-1))];
            if(maxKey == null)&#123;
                maxKey = item;
    
            &#125;
            else&#123;
                let intersect2 = [...new Set([...broadcast.get(maxKey)].filter(x =&gt; allAreas.indexOf(x)!=-1))];
                if(intersect.length &gt; intersect2.length)&#123;
                    maxKey = item;
                &#125;
            &#125;
        &#125;
        if(maxKey!=null)&#123;
            selects.push(maxKey);
            var preto_delete = [...new Set([...broadcast.get(maxKey)].filter(x =&gt; allAreas.indexOf(x)!=-1))];
            let item;
            for(var i = 0;i&lt;preto_delete.length;i++)&#123;
                item = allAreas.indexOf(preto_delete[i])
                allAreas.splice(item, item + 1);
            &#125;
        &#125;
    &#125;
    return selects;
&#125;
//创建广播电台，放入到Map中
var broadcast = new Map();
//将各个电台放入到broadcast中
broadcast.set(&#39;k1&#39;, [&quot;北京&quot;, &quot;上海&quot;, &quot;天津&quot;]);
broadcast.set(&#39;k2&#39;, [&quot;广州&quot;, &quot;北京&quot;, &quot;深圳&quot;]);
broadcast.set(&#39;k3&#39;, [&quot;成都&quot;, &quot;上海&quot;, &quot;杭州&quot;]);
broadcast.set(&#39;k4&#39;, [&quot;上海&quot;, &quot;天津&quot;]);
broadcast.set(&#39;k5&#39;, [&quot;杭州&quot;, &quot;大连&quot;]);

var allAreas = [&quot;北京&quot;, &quot;上海&quot;, &quot;天津&quot;, &quot;广州&quot;, &quot;深圳&quot;, &quot;成都&quot;, &quot;大连&quot;, &quot;杭州&quot;];
console.log(greedy(broadcast, allAreas));
</code></pre>
<h1 id="Prim算法（应用场景：修路问题）"><a href="#Prim算法（应用场景：修路问题）" class="headerlink" title="Prim算法（应用场景：修路问题）"></a>Prim算法（应用场景：修路问题）</h1><p>修路问题的本质就是最小生成树问题，最小生成树（Minimum Cost Spanning Tree），简称MST。<br>1).给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树；</p>
<p>2).N个顶点，一定有N-1条边</p>
<p>3).包含全部顶点</p>
<p>4).N-1条边都在图中</p>
<p>Prime算法介绍<br>1.Prime算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有（n-1）条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</p>
<ol start="2">
<li> 普利姆算法如下：<br>（1）设G=(V, E)是连通网，T=(U, D)是最小生成树，V,U是顶点集合， E,D是边的集合<br>（2）若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u] = 1<br>（3）若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui， vj）加入集合D中，标记visited[vj] = 1<br>（4）重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li>
</ol>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>（原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Timor7hao/article/details/108423423%EF%BC%89">https://blog.csdn.net/Timor7hao/article/details/108423423）</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>回溯算法：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>解决一个回溯问题，实际上就是一个决策树的遍历过程。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>三个步骤：</p>
<p>（1）开头写好跳出条件，满足条件才将当前结果加入总结果中。</p>
<p>（2）已经拿过的数不再拿。</p>
<p>（3）向下遍历，结束后回溯到上一步。<br>伪代码：</p>
<pre><code>result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:                  // (1)
        result.add(路径)
        return
​
    for 选择 in 选择列表:
        去掉已经拿过的数              // (2)
        做选择                       // (3)
        backtrack(路径, 选择列表)     
        撤销选择
</code></pre>
<p>3、leetcode真题（全排列、子集、组合、拓展题）</p>
<pre><code>全排列问题（leetcode46）

var allArray = function(nums) &#123;
    var res = []
    var dfs = function(path)&#123;
        if(nums.length === path.length)&#123;              //(1)
            res.push([...path]);
            return;
        &#125;
        for(let i=0; i&lt;nums.length; i++)&#123;
            if(path.indexOf(nums[i]) !== -1) &#123;        //(2)
                continue;
            &#125;
            path.push(nums[i]);                       //(3)
            dfs(path);
            path.pop();
 
        &#125;
    &#125;
    dfs([]);
    return res;
&#125;;
 
console.log(allArray([1,2,3]))          
// [[ 1, 2, 3 ],[ 1, 3, 2 ],[ 2, 1, 3 ],[ 2, 3, 1 ],[ 3, 1, 2 ],[ 3, 2, 1 ]]

子集问题（leetcode78）
</code></pre>
<p>和全排列区别：</p>
<p>1》所有可能的子集，每次递归中都将当前组合加入结果中，不用之前的结束条件。</p>
<p>2》[1,3]和[3,1]是相同的，故每次取数时要从其位置取后面的数，加个标志位start。</p>
<pre><code>var sonArray = function(nums) &#123;
    var res = [];
    var dfs = function(path,start) &#123;
        res.push([...path])                        //(1)
        for(let i=start; i&lt;nums.length; i++) &#123;     //(2)
            path.push(nums[i]);                    //(3)
            dfs(path,i+1);
            path.pop();
        &#125;
    &#125;
    dfs([],0)
    return res;
&#125;
 
console.log(sonArray([1,2,3]))
//[ [], [ 1 ], [ 1, 2 ], [ 1, 2, 3 ], [ 1, 3 ], [ 2 ], [ 2, 3 ], [ 3 ] ]

组合求和问题（leetcode39）
</code></pre>
<p>和全排列区别：</p>
<p>1》结束条件是满足目标target。</p>
<p>2》组合包括自身和，故每次取数时要从自己位置开始取数。</p>
<pre><code>var targetArray = function(nums, target) &#123;
    var res = [];
    var dfs = function(path,start) &#123;
        if(sum(path) === target) &#123;                  //(1)
            res.push([...path]);
            return;
        &#125;
        if(sum(path) &gt; target) &#123;
            return;
        &#125;
        for(let i=start; i&lt;nums.length; i++) &#123;     //(2)
            path.push(nums[i]);                    //(3)
            dfs(path.slice(), i);
            path.pop();
        &#125;
    &#125;
    dfs([],0)
    return res;
&#125;
function sum(arr) &#123;
    if(arr.length===0)
        return 0;
    return arr.reduce((a,b)=&gt;a+b)
&#125;
 
console.log(targetArray([2,3,5],8))
// [ [ 2, 2, 2, 2 ], [ 2, 3, 3 ], [ 3, 5 ] ]

拓展题
</code></pre>
<p>输入目标字符串：比如”南京“输出包含目标字符串的节点路径集合。</p>
<pre><code>function func(arr, str) &#123;
    var res = [];
    var recur = function(arr, path) &#123;
        let string = path.join(&#39;-&#39;);
        if(string.indexOf(str) !== -1)&#123;
            res.push(string);
        &#125;
        if(arr === undefined || arr.length === 0)
            return;
        
        for(let i=0; i&lt;arr.length; i++)&#123;
            path.push(arr[i].label);
            recur(arr[i].children, path);
            path.pop();
        &#125;
    &#125;
    recur(arr, []);
    return res;
&#125;
 
console.log(func([&#123;label:&#39;江苏省&#39;,children:[&#123;label:&#39;南京市&#39;,children:[&#123;label:&#39;xxx区&#39;,children:[]&#125;]&#125;]&#125;],&#39;南京&#39;))
//[ &#39;江苏省-南京市&#39;, &#39;江苏省-南京市-xxx区&#39; ]
</code></pre>
<h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><h2 id="构建单向的环形链表思路"><a href="#构建单向的环形链表思路" class="headerlink" title="构建单向的环形链表思路"></a>构建单向的环形链表思路</h2><ol>
<li>先创建第一个节点，让first指向该节点，并形成环形；</li>
<li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可。</li>
</ol>
<h2 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h2><ol>
<li>先让一个辅助指针（变量），指向first节点；</li>
<li>然后通过一个while循环遍历该环形链表即可，curBoy.next == first;即可。</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ol>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</li>
<li>堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，<strong>注意</strong>：没有要求节点的左孩子的值和右孩子的值的大小关系；</li>
<li>每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。</li>
<li>大顶堆特点：arr[i]&gt;=arr[2<em>i+1<br>] &amp;&amp; arr[i]&gt;=arr[2</em>i+2]//i对应第几个节点，i从0开始编号；小顶堆特点：arr[i]&lt;=arr[2<em>i+1] &amp;&amp; arr[i]&lt;=arr[2</em>i+2]。一般升序采用大顶堆，降序采用小顶堆。<h2 id="堆排序基本思想"><a href="#堆排序基本思想" class="headerlink" title="堆排序基本思想"></a>堆排序基本思想</h2></li>
</ol>
<p>堆排序的基本思想：</p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点</li>
<li>将其与末尾元素进行交换，此时末尾就是最大值</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。<br>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后得到一个有序序列了。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/01/06/Tree-Graph/" title="Tree&amp;Graph" itemprop="url">Tree&amp;Graph</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Weiling Wu" target="_blank" itemprop="author">Weiling Wu</a>
		
  <p class="article-time">
    <time datetime="2022-01-06T05:14:38.000Z" itemprop="datePublished"> Published 2022-01-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的概念："><a href="#树的概念：" class="headerlink" title="树的概念："></a>树的概念：</h2><p>树是一种数据结构，它是由n(n≥1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h2 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h2><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。<br>树的特点：</p>
<p>由二叉树定义以及图示分析得出二叉树有以下特点：<br>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<br>性质：</p>
<p>1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）<br>2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）<br>3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p>
<p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br>(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；<br>(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</p>
<h2 id="二叉树深度遍历"><a href="#二叉树深度遍历" class="headerlink" title="二叉树深度遍历"></a>二叉树深度遍历</h2><p>前序遍历，中序遍历，后序遍历。</p>
<p>前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。中序后序以此类推。</p>
<p><strong>//前序遍历</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
        function TreeNode(val) &#123;
          this.val = val;
          this.left = this.right = null;
         &#125;

        function preorderTraversal(root)&#123;
            const res = [];
            function inorder(root) &#123;
                if(root==null)
                    return;
                res.push(root.val);
                inorder(root.left);//递归
                inorder(root.right);
            &#125;
            inorder(root);

        &#125;
&lt;/script&gt;
</code></pre>
<p><strong>//中序遍历</strong></p>
<pre><code>function inorderTraversal(root)&#123;
    const res = [];
    function inorder(root) &#123;
        if(root==null)
            return;
        inorder(root.left);//递归
        res.push(root.val);
        inorder(root.right);
    &#125;
</code></pre>
<p><strong>//后序遍历</strong></p>
<pre><code>function postorderTraversal(root)&#123;
    const res = [];
    function inorder(root) &#123;
        if(root==null)
            return;
        inorder(root.left);//递归
        inorder(root.right);
        res.push(root.val);
    &#125;
</code></pre>
<h2 id="二叉树广度遍历–层次遍历"><a href="#二叉树广度遍历–层次遍历" class="headerlink" title="二叉树广度遍历–层次遍历"></a>二叉树广度遍历–层次遍历</h2><pre><code>     3   
    / \  
   9  20
       /  \   
    15   7 
返回其层次遍历结果：
[ [3], [9,20], [15,7] ]
</code></pre>
<p><strong>解题思路</strong></p>
<p>二叉树的层序遍历，即二叉树的广度遍历，先遍历根节点的相邻节点，再一次遍历相邻节点的子节点。广度遍历通常借助队列来实现。用队列来存储当前层的节点数，遍历当前层的节点，将当前层的节点依次推入数组subRes[]，再将当前节点的左右子节点推入队列中，进入下一层进行遍历，直到遍历完整棵树，即完成到二叉树的层序遍历。</p>
<pre><code>/**
 * Definition for a binary tree node.
 * function TreeNode(val) &#123;
 *     this.val = val;
 *     this.left = this.right = null;
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[][]&#125;
 */
//广度遍历 + 队列
var levelOrder = function(root) &#123;
    if(!root)&#123;
        return []
    &#125;
    var res = [] //结果最外层数组
    var queue = [root]
    while(queue.length&gt;0)&#123;
        var len = queue.length//当前层的节点数目
        var subRes = []
        for(var i=0;i&lt;len;i++)&#123;
            var node = queue.shift() //节点出列
            subRes.push(node.val) //将当前层的节点值加入subRes数组中
            //将下一层节点计入队列中
            if(node.left)&#123;
                queue.push(node.left)
            &#125;
            if(node.right)&#123;
                queue.push(node.right)
            &#125;
        &#125;
        res.push(subRes)
    &#125;
    return res
&#125;;
</code></pre>
<h2 id="二叉树结点删除"><a href="#二叉树结点删除" class="headerlink" title="二叉树结点删除"></a>二叉树结点删除</h2><p>规定：</p>
<p>1）如果删除的节点是叶子节点，则删除该节点</p>
<p>2）如果删除的节点是非叶子节点，则删除该子树</p>
<p>思路：</p>
<p>1）考虑树是空树root。那么只有一个root节点，则等价将二叉树置空。</p>
<p>2）因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否删除节点，而不能去判断当前节点是不是需要删除节点。</p>
<p>3）如果当前节点的左子节点不为空，并且左子节点就是需要删除节点，就将this.left = null，并且就返回（结束递归删除）</p>
<p>4）如果当前节点的右子节点不为空，并且右子节点就是需要删除节点，就将this.right= null，并且就返回（结束递归删除）</p>
<p>5）如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除</p>
<p>6）如果第4步没有删除节点，则应当向右子树进行递归删除。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>(引自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42126431/article/details/89537923">https://blog.csdn.net/weixin_42126431/article/details/89537923</a>)</p>
<h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><ol>
<li><p>有一条边相连的顶点叫相邻顶点；</p>
</li>
<li><p>一个顶点的度就是该顶点的相邻顶点数；</p>
</li>
<li><p>路径指顶点组成的连续序列；</p>
</li>
<li><p>简单路径没有重复顶点；</p>
</li>
<li><p>有向图和无向图</p>
</li>
</ol>
<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><ul>
<li><p>邻接矩阵 array[i][j] ===1代表i节点和j节点相邻，否则不相邻</p>
</li>
<li><p>邻接表 相当于把每个节点的相邻节点一一列举出来。</p>
</li>
<li><p>关联矩阵 形式和邻接矩阵一样，只是把邻接矩阵的直接维度换成对应的边，适用于边比顶点多的情况。</p>
</li>
</ul>
<h2 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h2><p>图由边的集合及顶点的集合组成。边是有方向的是有序图（有向图），否则就是无序图（无向图）。图中的一系列顶点构成路径，路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。</p>
<p>用邻接表来表示边，即将与某一顶点的相邻的边表示为由该顶点的相邻顶点列表构成的数组，并以该顶点作为索引。比如，如果顶点 2 与顶点 0、 1、3、4 相连，那么就将0、1、3、4存储在数组中索引为 2 的位置。</p>
<p><strong>Graph 类定义图</strong></p>
<pre><code>function Graph(v) &#123;
  this.vertices = v;  //顶点的数量
  this.edges = 0;
  this.adj = []; //边，邻接矩阵
  for (var i = 0; i &lt; this.vertices; ++i) &#123;
    this.adj[i] = [];  //保存与顶点 i 相邻的顶点列表
  &#125;
  this.addEdge = addEdge;
  this.showGraph = showGraph;
  this.dfs = dfs;
  this.bfs = bfs;
  this.marked = [];  //保存未访问过的顶点
  for (var i = 0; i &lt; this.vertices; ++i) &#123;
    this.marked[i] = false;
  &#125;
  this.pathTo = pathTo;
  this.hasPathTo = hashPathTo;
  this.edgeTo = [];
&#125;
</code></pre>
<p><strong>addEdge(A,B)</strong> 添加边，先查找顶点 A 的邻接表，将顶点 B 添加到列表中，然后再查找顶点 B 的邻接表，将顶点 A 加入列表。最后，将边数加 1。</p>
<pre><code>function addEdge(v, w) &#123;
　　this.ajd[v].push(w);
　　this.adj[w].push(v);
　　this.edges++;
&#125;
</code></pre>
<p><strong>showGraph()</strong> 方法显示所有顶点及其相邻顶点列表</p>
<pre><code>function showGraph() &#123;
  for (var i = 0; i &lt; this.vertices; ++i) &#123;
    var str = &#39;&#39;;
    str += i + &quot; -&gt; &quot;;
    for (var j = 0; j &lt; this.vertices; ++j) &#123;
      if (this.adj[i][j] != undefined) &#123;
        str += this.adj[i][j] + &#39; &#39;;
      &#125;
    &#125;
    console.log(str);
  &#125;
&#125;
</code></pre>
<h2 id="搜索图"><a href="#搜索图" class="headerlink" title="搜索图"></a>搜索图</h2><p>确定从一个指定的顶点可以到达其他哪些顶点，有两种搜索方法：<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>。</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>从起始顶点开始追溯，直到到达最后一个顶点，然后回溯， 继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。当访问一个没有访问过的顶点时，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。</p>
<pre><code>function dfs(v) &#123;
  this.marked[v] = true;
  if (this.adj[v] != undefined) &#123;
    console.log(&quot;Visited vertex: &quot; + v);
  &#125;
  for(var w of this.adj[v]) &#123;
    if (!this.marked[w]) &#123;
      this.dfs(w);
    &#125;
  &#125;
&#125;
//调用
g = new Graph(5);
g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 3);
g.addEdge(2, 4);
g.showGraph();
g.dfs(0);
</code></pre>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。</p>
<pre><code>function bfs(s) &#123;
  var queue = [];
  this.marked[s] = true;
  queue.push(s); // 添加到队尾
  while (queue.length &gt; 0) &#123;
    var v = queue.shift(); // 从队首移除
    if (v != undefined) &#123;
      console.log(&quot;Visisted vertex: &quot; + v);
    &#125;
    for(var w of this.adj[v]) &#123;
      if (!this.marked[w]) &#123;this.marked[w] = true;
        queue.push(w);
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/jQuery-bootstrap/" title="jQuery &amp; bootstrap">jQuery &amp; bootstrap<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/sort/" title="sort">sort<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Weiling Wu in Google. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2022 
		
		<a href="/about" target="_blank" title="Weiling Wu">Weiling Wu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
