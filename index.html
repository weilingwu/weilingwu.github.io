<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="font-end study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="font-end study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiling Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>font-end study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">font-end study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/09/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/09/es6/" class="post-title-link" itemprop="url">es6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-09 15:26:41 / Modified: 16:51:52" itemprop="dateCreated datePublished" datetime="2022-01-09T15:26:41+08:00">2022-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-关键字-let-和-const。"><a href="#JavaScript-关键字-let-和-const。" class="headerlink" title="JavaScript 关键字: let 和 const。"></a>JavaScript 关键字: let 和 const。</h1><p><strong>let 声明的变量只在 let 命令所在的代码块内有效。</strong></p>
<p><strong>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</strong></p>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>基本用法:</p>
<pre><code>&#123;
  let a = 0;
  a   // 0
&#125;
a   // 报错 ReferenceError: a is not defined
</code></pre>
<p>代码块内有效</p>
<p><em>let 是在代码块内有效，var 是在全局范围内有效:</em></p>
<pre><code>&#123;
  let a = 0;
  var b = 1;
&#125;
a  // ReferenceError: a is not defined
b  // 1
</code></pre>
<p><em>不能重复声明，let 只能声明一次 var 可以声明多次:</em></p>
<pre><code>let a = 1;
let a = 2;
var b = 3;
var b = 4;
a  // Identifier &#39;a&#39; has already been declared
b  // 4
</code></pre>
<p>for 循环计数器很适合用 let</p>
<pre><code>for (var i = 0; i &lt; 10; i++) &#123;
  setTimeout(function()&#123;
    console.log(i);
  &#125;)
&#125;
// 输出十个 10
for (let j = 0; j &lt; 10; j++) &#123;
  setTimeout(function()&#123;
    console.log(j);
  &#125;)
&#125;
// 输出 0123456789
</code></pre>
<p>变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。</p>
<p>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。<br>不存在变量提升</p>
<p>let 不存在变量提升，var 会变量提升:</p>
<pre><code>console.log(a);  //ReferenceError: a is not defined
let a = &quot;apple&quot;;

console.log(b);  //undefined
var b = &quot;banana&quot;;
</code></pre>
<p>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。</p>
<p>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。</p>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p><strong>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</strong></p>
<p>基本用法:</p>
<pre><code>const PI = &quot;3.1415926&quot;;
PI  // 3.1415926

const MY_AGE;  // SyntaxError: Missing initializer in const declaration    
</code></pre>
<p>暂时性死区:</p>
<pre><code>var PI = &quot;a&quot;;
if(true)&#123;
  console.log(PI);  // ReferenceError: PI is not defined
  const PI = &quot;3.1415926&quot;;
&#125;
</code></pre>
<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>
<p><strong>注意要点</strong></p>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是对赋值运算符的扩展。<strong>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</strong></p>
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。<br>解构模型</p>
<p>在解构中，有下面两部分参与：<strong>解构的源，解构赋值表达式的右边部分；解构的目标，解构赋值表达式的左边部分。</strong></p>
<h2 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h2><p>基本</p>
<pre><code>let [a, b, c] = [1, 2, 3];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可嵌套</p>
<pre><code>let [a, [[b], c]] = [1, [[2], 3]];
// a = 1
// b = 2
// c = 3
</code></pre>
<p>可忽略</p>
<pre><code>let [a, , b] = [1, 2, 3];
// a = 1
// b = 3
</code></pre>
<p>不完全解构</p>
<pre><code>let [a = 1, b] = []; // a = 1, b = undefined
</code></pre>
<p>剩余运算符</p>
<pre><code>let [a, ...b] = [1, 2, 3];
//a = 1
//b = [2, 3]
</code></pre>
<h2 id="字符串等"><a href="#字符串等" class="headerlink" title="字符串等"></a>字符串等</h2><p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<pre><code>let [a, b, c, d, e] = &#39;hello&#39;;
// a = &#39;h&#39;
// b = &#39;e&#39;
// c = &#39;l&#39;
// d = &#39;l&#39;
// e = &#39;o&#39;
</code></pre>
<p>解构默认值</p>
<pre><code>let [a = 2] = [undefined]; // a = 2
</code></pre>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<pre><code>let [a = 3, b = a] = [];     // a = 3, b = 3
let [a = 3, b = a] = [1];    // a = 1, b = 1
let [a = 3, b = a] = [1, 2]; // a = 1, b = 2
</code></pre>
<p>a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3<br>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1<br>a 与 b 正常解构赋值，匹配结果：a = 1，b = 2 </p>
<p>对象模型的解构（Object）</p>
<p>基本</p>
<pre><code>let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
// foo = &#39;aaa&#39;
// bar = &#39;bbb&#39;
 
let &#123; baz : foo &#125; = &#123; baz : &#39;ddd&#39; &#125;;
// foo = &#39;ddd&#39;
</code></pre>
<p>可嵌套可忽略</p>
<pre><code>let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123; y &#125;] &#125; = obj;
// x = &#39;hello&#39;
// y = &#39;world&#39;
let obj = &#123;p: [&#39;hello&#39;, &#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [x, &#123;  &#125;] &#125; = obj;
// x = &#39;hello&#39;
</code></pre>
<p>不完全解构</p>
<pre><code>let obj = &#123;p: [&#123;y: &#39;world&#39;&#125;] &#125;;
let &#123;p: [&#123; y &#125;, x ] &#125; = obj;
// x = undefined
// y = &#39;world&#39;
</code></pre>
<p>剩余运算符</p>
<pre><code>let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;;
// a = 10
// b = 20
// rest = &#123;c: 30, d: 40&#125;
</code></pre>
<p>解构默认值</p>
<pre><code>let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;
// a = 3; b = 5;
let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;
// aa = 3; bb = 5;
</code></pre>
<h1 id="ES6-Map-与-Set"><a href="#ES6-Map-与-Set" class="headerlink" title="ES6 Map 与 Set"></a>ES6 Map 与 Set</h1><h2 id="Map-对象"><a href="#Map-对象" class="headerlink" title="Map 对象"></a>Map 对象</h2><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>Maps 和 Objects 的区别：</p>
<pre><code>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。
Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。
Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。
Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。
</code></pre>
<h2 id="Map-中的-key"><a href="#Map-中的-key" class="headerlink" title="Map 中的 key"></a>Map 中的 key</h2><pre><code>var myMap = new Map();
var keyString = &quot;a string&quot;; 
 
myMap.set(keyString, &quot;和键&#39;a string&#39;关联的值&quot;);
 
myMap.get(keyString);    // &quot;和键&#39;a string&#39;关联的值&quot;
myMap.get(&quot;a string&quot;);   // &quot;和键&#39;a string&#39;关联的值&quot;
                         // 因为 keyString === &#39;a string&#39;
</code></pre>
<p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p>
<h3 id="Map-的迭代"><a href="#Map-的迭代" class="headerlink" title="Map 的迭代"></a>Map 的迭代</h3><p>对 Map 进行遍历，以下两个最高级。<br><strong>for…of</strong></p>
<pre><code>var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);

// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

for (var [key, value] of myMap) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
for (var [key, value] of myMap.entries()) &#123;
  console.log(key + &quot; = &quot; + value);
&#125;
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */

// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;

for (var key of myMap.keys()) &#123;
  console.log(key);
&#125;
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */

// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;
for (var value of myMap.values()) &#123;
  console.log(value);
&#125;
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */

    forEach()
    var myMap = new Map();
    myMap.set(0, &quot;zero&quot;);
    myMap.set(1, &quot;one&quot;);
 
// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;

    myMap.forEach(function(value, key) &#123;
      console.log(key + &quot; = &quot; + value);
    &#125;, myMap)
</code></pre>
<h3 id="Map-对象的操作"><a href="#Map-对象的操作" class="headerlink" title="Map 对象的操作"></a>Map 对象的操作</h3><h4 id="Map-与-Array的转换"><a href="#Map-与-Array的转换" class="headerlink" title="Map 与 Array的转换"></a>Map 与 Array的转换</h4><pre><code>var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];

// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象

var myMap = new Map(kvArray);

// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组

var outArray = Array.from(myMap);
</code></pre>
<h4 id="Map-的克隆"><a href="#Map-的克隆" class="headerlink" title="Map 的克隆"></a>Map 的克隆</h4><pre><code>var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);
var myMap2 = new Map(myMap1);

console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。
</code></pre>
<h4 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h4><pre><code>var first = new Map([[1, &#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;],]);
var second = new Map([[1, &#39;uno&#39;], [2, &#39;dos&#39;]]);

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three

var merged = new Map([...first, ...second]);
</code></pre>
<h2 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<h3 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h3><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<pre><code>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
undefined 与 undefined 是恒等的，所以不重复；
NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。
</code></pre>
<p>代码</p>
<pre><code>let mySet = new Set();
 
mySet.add(1); // Set(1) &#123;1&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125;
mySet.add(5); // Set(2) &#123;1, 5&#125; 这里体现了值的唯一性
mySet.add(&quot;some text&quot;); 
// Set(3) &#123;1, 5, &quot;some text&quot;&#125; 这里体现了类型的多样性
var o = &#123;a: 1, b: 2&#125;; 
mySet.add(o);
mySet.add(&#123;a: 1, b: 2&#125;); 
// Set(5) &#123;1, 5, &quot;some text&quot;, &#123;…&#125;, &#123;…&#125;&#125; 
</code></pre>
<p>// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储<br>类型转换</p>
<p>Array</p>
<pre><code>// Array 转 Set
var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);
// 用...操作符，将 Set 转 Array
var myArray = [...mySet];
</code></pre>
<p>String</p>
<pre><code>// String 转 Set
var mySet = new Set(&#39;hello&#39;);  // Set(4) &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;&#125;
// 注：Set 中 toString 方法是不能将 Set 转换成 String
</code></pre>
<h3 id="Set-对象作用"><a href="#Set-对象作用" class="headerlink" title="Set 对象作用"></a>Set 对象作用</h3><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><pre><code>var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]
</code></pre>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // &#123;1, 2, 3, 4&#125;
</code></pre>
<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x =&gt; b.has(x))); // &#123;2, 3&#125;
</code></pre>
<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x =&gt; !b.has(x))); // &#123;1&#125;
</code></pre>
<h1 id="字符串拓展方法"><a href="#字符串拓展方法" class="headerlink" title="字符串拓展方法"></a>字符串拓展方法</h1><h2 id="子串的识别"><a href="#子串的识别" class="headerlink" title="子串的识别"></a>子串的识别</h2><p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p>
<ul>
<li><p><strong>includes()：返回布尔值，判断是否找到参数字符串。</strong></p>
</li>
<li><p><strong>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。</strong></p>
</li>
<li><p><strong>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。</strong></p>
</li>
</ul>
<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>
<pre><code>let string = &quot;apple,banana,orange&quot;;
string.includes(&quot;banana&quot;);     // true
string.startsWith(&quot;apple&quot;);    // true
string.endsWith(&quot;apple&quot;);      // false
string.startsWith(&quot;banana&quot;,6)  // true
</code></pre>
<p><strong>注意点</strong>：</p>
<ul>
<li><p>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</p>
</li>
<li><p>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</p>
</li>
</ul>
<h2 id="字符串重复"><a href="#字符串重复" class="headerlink" title="字符串重复"></a>字符串重复</h2><p><strong>repeat()：返回新的字符串，表示将字符串重复指定次数返回。</strong></p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(2));  // &quot;Hello,Hello,&quot;
</code></pre>
<p>如果参数是小数，向下取整</p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(3.2));  // &quot;Hello,Hello,Hello,&quot;
</code></pre>
<p>如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(-0.5));  // &quot;&quot; 
</code></pre>
<p>如果参数是 NaN，等同于 repeat 零次</p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(NaN));  // &quot;&quot; 
</code></pre>
<p>如果参数是负数或者 Infinity ，会报错:</p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(-1));  
// RangeError: Invalid count value

console.log(&quot;Hello,&quot;.repeat(Infinity));  
// RangeError: Invalid count value
</code></pre>
<p>如果传入的参数是字符串，则会先将字符串转化为数字</p>
<pre><code>console.log(&quot;Hello,&quot;.repeat(&quot;hh&quot;)); // &quot;&quot;
console.log(&quot;Hello,&quot;.repeat(&quot;2&quot;));  // &quot;Hello,Hello,&quot;
</code></pre>
<h2 id="字符串补全"><a href="#字符串补全" class="headerlink" title="字符串补全"></a>字符串补全</h2><p><strong>padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</strong><br><strong>padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</strong></p>
<p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>
<pre><code>console.log(&quot;h&quot;.padStart(5,&quot;o&quot;));  // &quot;ooooh&quot;
console.log(&quot;h&quot;.padEnd(5,&quot;o&quot;));    // &quot;hoooo&quot;
console.log(&quot;h&quot;.padStart(5));      // &quot;    h&quot;
</code></pre>
<p>如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</p>
<pre><code>console.log(&quot;hello&quot;.padStart(5,&quot;A&quot;));  // &quot;hello&quot;
</code></pre>
<p>如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</p>
<pre><code>console.log(&quot;hello&quot;.padEnd(10,&quot;,world!&quot;));  // &quot;hello,worl&quot;
</code></pre>
<p>常用于补全位数：</p>
<pre><code>console.log(&quot;123&quot;.padStart(10,&quot;0&quot;));  // &quot;0000000123&quot;
</code></pre>
<h1 id="es6数组"><a href="#es6数组" class="headerlink" title="es6数组"></a>es6数组</h1><h2 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h2><pre><code>Array.of()
</code></pre>
<p>将参数中所有值作为元素形成数组。</p>
<pre><code>console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]

// 参数值可为不同类型
console.log(Array.of(1, &#39;2&#39;, true)); // [1, &#39;2&#39;, true]
 
// 参数为空时返回空数组
console.log(Array.of()); // []
Array.from()
</code></pre>
<p>将类数组对象或可迭代对象转化为数组。</p>
<pre><code>// 参数为数组,返回与原数组一样的数组
console.log(Array.from([1, 2])); // [1, 2]
 
// 参数含空位
console.log(Array.from([1, , 3])); // [1, undefined, 3]
</code></pre>
<p>参数</p>
<pre><code>Array.from(arrayLike[, mapFn[, thisArg]])
</code></pre>
<p>返回值为转换后的数组。</p>
<p>arrayLike</p>
<p>想要转换的类数组对象或可迭代对象。</p>
<pre><code>console.log(Array.from([1, 2, 3])); // [1, 2, 3]
</code></pre>
<p>mapFn</p>
<p>可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。</p>
<p>console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6]</p>
<p>thisArg</p>
<p>可选，用于指定 map 函数执行时的 this 对象。</p>
<pre><code>let map = &#123;
    do: function(n) &#123;
        return n * 2;
    &#125;
&#125;
let arrayLike = [1, 2, 3];
console.log(Array.from(arrayLike, function (n)&#123;
    return this.do(n);
&#125;, map)); // [2, 4, 6]
</code></pre>
<p>类数组对象</p>
<p>一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符。</p>
<pre><code>let arr = Array.from(&#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
  length: 3
&#125;);
console.log(arr); // [&#39;1&#39;, &#39;2&#39;, 3]
</code></pre>
<p>// 没有 length 属性,则返回空数组</p>
<pre><code>let array = Array.from(&#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
&#125;);
console.log(array); // []
</code></pre>
<p>// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  </p>
<pre><code>    let array1 = Array.from(&#123;
      a: 1,
      b: 2,
      length: 2
    &#125;);
    console.log(array1); // [undefined, undefined]
</code></pre>
<p>转换可迭代对象</p>
<p>转换 map</p>
<pre><code>let map = new Map();
map.set(&#39;key0&#39;, &#39;value0&#39;);
map.set(&#39;key1&#39;, &#39;value1&#39;);
console.log(Array.from(map)); // [[&#39;key0&#39;, &#39;value0&#39;],[&#39;key1&#39;,
// &#39;value1&#39;]]
</code></pre>
<p>转换 set</p>
<pre><code>let arr = [1, 2, 3];
let set = new Set(arr);
console.log(Array.from(set)); // [1, 2, 3]
</code></pre>
<p>转换字符串<br>let str = ‘abc’;<br>console.log(Array.from(str)); // [“a”, “b”, “c”]<br>扩展的方法<br>查找</p>
<p>find()</p>
<p>查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。<br>let arr = Array.of(1, 2, 3, 4);<br>console.log(arr.find(item =&gt; item &gt; 2)); // 3</p>
<p>// 数组空位处理为 undefined<br>console.log([, 1].find(n =&gt; true)); // undefined</p>
<p>findIndex()</p>
<p>查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。<br>let arr = Array.of(1, 2, 1, 3);<br>// 参数1：回调函数<br>// 参数2(可选)：指定回调函数中的 this 值<br>console.log(arr.findIndex(item =&gt; item == 2)); // 1</p>
<p>// 数组空位处理为 undefined<br>console.log([, 1].findIndex(n =&gt; true)); //0<br>填充</p>
<p>fill()</p>
<p>将一定范围索引的数组元素内容填充为单个指定的值。<br>let arr = Array.of(1, 2, 3, 4);<br>// 参数1：用来填充的值<br>// 参数2：被填充的起始索引<br>// 参数3(可选)：被填充的结束索引，默认为数组末尾<br>console.log(arr.fill(0,1,2)); // [1, 0, 3, 4]</p>
<p>copyWithin()</p>
<p>将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。<br>// 参数1：被修改的起始索引<br>// 参数2：被用来覆盖的数据的起始索引<br>// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾<br>console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]</p>
<p>// 参数1为负数表示倒数<br>console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]</p>
<p>console.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]<br>遍历</p>
<p>entries()</p>
<p>遍历键值对。<br>for(let [key, value] of [‘a’, ‘b’].entries()){<br>    console.log(key, value);<br>}<br>// 0 “a”<br>// 1 “b”</p>
<p>// 不使用 for… of 循环<br>let entries = [‘a’, ‘b’].entries();<br>console.log(entries.next().value); // [0, “a”]<br>console.log(entries.next().value); // [1, “b”]</p>
<p>// 数组含空位<br>console.log([…[,’a’].entries()]); // [[0, undefined], [1, “a”]]</p>
<p>keys()</p>
<p>遍历键名。<br>for(let key of [‘a’, ‘b’].keys()){<br>    console.log(key);<br>}<br>// 0<br>// 1</p>
<p>// 数组含空位<br>console.log([…[,’a’].keys()]); // [0, 1]</p>
<p>values()</p>
<p>遍历键值。<br>for(let value of [‘a’, ‘b’].values()){<br>    console.log(value);<br>}<br>// “a”<br>// “b”</p>
<p>// 数组含空位<br>console.log([…[,’a’].values()]); // [undefined, “a”]<br>包含</p>
<p>includes()</p>
<p>数组是否包含指定值。</p>
<p>注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名。</p>
<pre><code>// 参数1：包含的指定值
[1, 2, 3].includes(1);    // true
 
// 参数2：可选，搜索的起始索引，默认为0
[1, 2, 3].includes(1, 2); // false
 
// NaN 的包含判断
[1, NaN, 3].includes(NaN); // true
</code></pre>
<p>嵌套数组转一维数组</p>
<pre><code>flat()
console.log([1 ,[2, 3]].flat()); // [1, 2, 3]
 
// 指定转换的嵌套层数
console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]
 
// 不管嵌套多少层
console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]
 
// 自动跳过空位
console.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3]
</code></pre>
<p>flatMap()</p>
<p>先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。</p>
<pre><code>// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组
// 参数2：指定遍历函数中 this 的指向
console.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6]
</code></pre>
<p>数组缓冲区</p>
<p>数组缓冲区是内存中的一段地址。</p>
<p>定型数组的基础。</p>
<p>实际字节数在创建时确定，之后只可修改其中的数据，不可修改大小。<br>创建数组缓冲区</p>
<p>通过构造函数创建:</p>
<pre><code>let buffer = new ArrayBuffer(10);
console.log(buffer.byteLength); // 10
分割已有数组缓冲区
let buffer = new ArrayBuffer(10);
let buffer1 = buffer.slice(1, 3);
console.log(buffer1.byteLength); // 2
</code></pre>
<p>视图</p>
<p>视图是用来操作内存的接口。</p>
<p>视图可以操作数组缓冲区或缓冲区字节的子集,并按照其中一种数值数据类型来读取和写入数据。</p>
<p>DataView 类型是一种通用的数组缓冲区视图,其支持所有8种数值型数据类型。</p>
<p>创建:<br>// 默认 DataView 可操作数组缓冲区全部内容</p>
<pre><code>let buffer = new ArrayBuffer(10);
    dataView = new DataView(buffer); 
dataView.setInt8(0,1);
console.log(dataView.getInt8(0)); // 1
</code></pre>
<p>// 通过设定偏移量(参数2)与长度(参数3)指定 DataView 可操作的字节范围</p>
<pre><code>let buffer1 = new ArrayBuffer(10);
    dataView1 = new DataView(buffer1, 0, 3);
dataView1.setInt8(5,1); // RangeError
</code></pre>
<p>定型数组</p>
<p>数组缓冲区的特定类型的视图。</p>
<p>可以强制使用特定的数据类型，而不是使用通用的 DataView 对象来操作数组缓冲区。<br>创建</p>
<p>通过数组缓冲区生成</p>
<pre><code>let buffer = new ArrayBuffer(10),
    view = new Int8Array(buffer);
console.log(view.byteLength); // 10
</code></pre>
<p>通过构造函数</p>
<pre><code>let view = new Int32Array(10);
console.log(view.byteLength); // 40
console.log(view.length);     // 10
 
// 不传参则默认长度为0
// 在这种情况下数组缓冲区分配不到空间，创建的定型数组不能用来保存数据

let view1 = new Int32Array();
console.log(view1.byteLength); // 0
console.log(view1.length);     // 0
</code></pre>
<p>// 可接受参数包括定型数组、可迭代对象、数组、类数组对象</p>
<pre><code>let arr = Array.from(&#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
  length: 3
&#125;);
let view2 = new Int16Array([1, 2]),
    view3 = new Int32Array(view2),
    view4 = new Int16Array(new Set([1, 2, 3])),
    view5 = new Int16Array([1, 2, 3]),
    view6 = new Int16Array(arr);
console.log(view2 .buffer === view3.buffer); // false
console.log(view4.byteLength); // 6
console.log(view5.byteLength); // 6
console.log(view6.byteLength); // 6
</code></pre>
<p>注意要点</p>
<p>length 属性不可写，如果尝试修改这个值，在非严格模式下会直接忽略该操作，在严格模式下会抛出错误。</p>
<pre><code>let view = new Int16Array([1, 2]);
view.length = 3;
console.log(view.length); // 2
</code></pre>
<p>定型数组可使用 entries()、keys()、values()进行迭代。</p>
<pre><code>let view = new Int16Array([1, 2]);
for(let [k, v] of view.entries())&#123;
    console.log(k, v);
&#125;
// 0 1
// 1 2
</code></pre>
<p>find() 等方法也可用于定型数组，但是定型数组中的方法会额外检查数值类型是否安全,也会通过 Symbol.species 确认方法的返回值是定型数组而非普通数组。concat() 方法由于两个定型数组合并结果不确定，故不能用于定型数组；另外，由于定型数组的尺寸不可更改,可以改变数组的尺寸的方法，例如 splice() ，不适用于定型数组。</p>
<pre><code>let view = new Int16Array([1, 2]);
view.find((n) &gt; 1); // 2
</code></pre>
<p>所有定型数组都含有静态 of() 方法和 from() 方法,运行效果分别与 Array.of() 方法和 Array.from() 方法相似,区别是定型数组的方法返回定型数组,而普通数组的方法返回普通数组。</p>
<pre><code>let view = Int16Array.of(1, 2);
console.log(view instanceof Int16Array); // true
</code></pre>
<p>定型数组不是普通数组，不继承自 Array 。</p>
<pre><code>let view = new Int16Array([1, 2]);
console.log(Array.isArray(view)); // false
</code></pre>
<p>定型数组中增加了 set() 与 subarray() 方法。 set() 方法用于将其他数组复制到已有定型数组, subarray() 用于提取已有定型数组的一部分形成新的定型数组。<br>// set 方法<br>// 参数1：一个定型数组或普通数组<br>// 参数2：可选，偏移量，开始插入数据的位置，默认为0</p>
<pre><code>let view= new Int16Array(4);
view.set([1, 2]);
view.set([3, 4], 2);
console.log(view); // [1, 2, 3, 4]
</code></pre>
<p>// subarray 方法<br>// 参数1：可选，开始位置<br>// 参数2：可选，结束位置(不包含结束位置)</p>
<pre><code>let view= new Int16Array([1, 2, 3, 4]), 
    subview1 = view.subarray(), 
    subview2 = view.subarray(1), 
    subview3 = view.subarray(1, 3);
console.log(subview1); // [1, 2, 3, 4]
console.log(subview2); // [2, 3, 4]
console.log(subview3); // [2, 3]
</code></pre>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><pre><code>let arr = [1, 2],
    arr1 = [...arr];
console.log(arr1); // [1, 2]

// 数组含空位
let arr2 = [1, , 3],
    arr3 = [...arr2];
console.log(arr3); [1, undefined, 3]
</code></pre>
<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><pre><code>console.log([...[1, 2],...[3, 4]]); // [1, 2, 3, 4]
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/09/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/09/%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">刷题经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-09 09:53:11 / Modified: 15:24:41" itemprop="dateCreated datePublished" datetime="2022-01-09T09:53:11+08:00">2022-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>链表求中点：</p>
<pre><code>var slow = head, fast = head.next;
while(fast!=null &amp;&amp; fast.next!=null)&#123;
    slow = slow.next;
    fast = fast.next.next;
&#125;
</code></pre>
<p>围成圆，提取的位置不能相邻：</p>
<p>（采用枚举法）<br>两种情况：1.有头没尾；2.没头有尾</p>
<p>三数之和：</p>
<pre><code>var threeSum = function(nums) &#123;
    const len = nums.length;
    if(len &lt; 3) return [];
    nums.sort((a, b) =&gt; a - b);
    const resSet = new Set();
    for(let i = 0; i &lt; len - 2; i++) &#123;
        if(nums[i] &gt; 0) break;
        let l = i + 1, r = len - 1;
        while(l &lt; r) &#123;
            const sum = nums[i] + nums[l] + nums[r];
            if(sum &lt; 0) &#123; l++; continue &#125;;
            if(sum &gt; 0) &#123; r--; continue &#125;;
            resSet.add(`$&#123;nums[i]&#125;,$&#123;nums[l]&#125;,$&#123;nums[r]&#125;`);
            l++;
            r--;
        &#125;
    &#125;
    return Array.from(resSet).map(i =&gt; i.split(&quot;,&quot;));
&#125;;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/php/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/php/" class="post-title-link" itemprop="url">hph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 19:43:01 / Modified: 21:21:42" itemprop="dateCreated datePublished" datetime="2022-01-06T19:43:01+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>PHP 变量规则</strong>：</p>
<ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）</li>
<li>变量名不能包含空格</li>
<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li>
</ul>
<pre><code>&lt;?php
$txt=&quot;Hello world!&quot;;
$x=5;
$y=10.5;
echo $txt.$x.$y
?&gt;
</code></pre>
<h3 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h3><p>变量的作用域是脚本中变量可被引用/使用的部分。</p>
<p>PHP 有四种不同的变量作用域：</p>
<ul>
<li><p>local</p>
</li>
<li><p>global</p>
</li>
<li><p>static</p>
</li>
<li><p>parameter</p>
</li>
</ul>
<p><strong>局部和全局作用域</strong></p>
<pre><code> &lt;?php
$x=5; // 全局变量

function myTest()
&#123;
    $y=10; // 局部变量
    echo &quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;;
    echo &quot;变量 x 为: $x&quot;;
    echo &quot;&lt;br&gt;&quot;;
    echo &quot;变量 y 为: $y&quot;;
&#125; 

myTest();

echo &quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;;
echo &quot;变量 x 为: $x&quot;;
echo &quot;&lt;br&gt;&quot;;
echo &quot;变量 y 为: $y&quot;;
?&gt; 
</code></pre>
<p><strong>global</strong> 关键字用于函数内访问全局变量。在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：</p>
<pre><code>&lt;?php
$x=5;
$y=10;
 
function myTest()
&#123;
    global $x,$y;
    $y=$x+$y;
&#125;
 
myTest();
echo $y; // 输出 15
?&gt;
</code></pre>
<p><strong>PHP echo 语句</strong></p>
<p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p>
<pre><code>&lt;?php
echo &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;
echo &quot;Hello world!&lt;br&gt;&quot;;
echo &quot;我要学 PHP!&lt;br&gt;&quot;;
echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;
?&gt;
</code></pre>
<p><strong>表单验证实例</strong>：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;My first PHP page&lt;/h1&gt;

&lt;?php
// 定义变量并默认设置为空值
$nameErr = $emailErr = $genderErr = $websiteErr = &quot;&quot;;
$name = $email = $gender = $comment = $website = &quot;&quot;;

if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)
&#123;
    if (empty($_POST[&quot;name&quot;]))
    &#123;
        $nameErr = &quot;名字是必需的&quot;;
    &#125;
    else
    &#123;
        $name = test_input($_POST[&quot;name&quot;]);
        // 检测名字是否只包含字母跟空格
        if (!preg_match(&quot;/^[a-zA-Z ]*$/&quot;,$name))
        &#123;
            $nameErr = &quot;只允许字母和空格&quot;; 
        &#125;
    &#125;
    
    if (empty($_POST[&quot;email&quot;]))
    &#123;
      $emailErr = &quot;邮箱是必需的&quot;;
    &#125;
    else
    &#123;
        $email = test_input($_POST[&quot;email&quot;]);
        // 检测邮箱是否合法
        if (!preg_match(&quot;/([\w\-]+\@[\w\-]+\.[\w\-]+)/&quot;,$email))
        &#123;
            $emailErr = &quot;非法邮箱格式&quot;; 
        &#125;
    &#125;
    
    if (empty($_POST[&quot;website&quot;]))
    &#123;
        $website = &quot;&quot;;
    &#125;
    else
    &#123;
        $website = test_input($_POST[&quot;website&quot;]);
        // 检测 URL 地址是否合法
        if (!preg_match(&quot;/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i&quot;,$website))
        &#123;
            $websiteErr = &quot;非法的 URL 的地址&quot;; 
        &#125;
    &#125;
    
    if (empty($_POST[&quot;comment&quot;]))
    &#123;
        $comment = &quot;&quot;;
    &#125;
    else
    &#123;
        $comment = test_input($_POST[&quot;comment&quot;]);
    &#125;
    
    if (empty($_POST[&quot;gender&quot;]))
    &#123;
        $genderErr = &quot;性别是必需的&quot;;
    &#125;
    else
    &#123;
        $gender = test_input($_POST[&quot;gender&quot;]);
    &#125;
&#125;

function test_input($data)
&#123;
    $data = trim($data);
    $data = stripslashes($data);
    $data = htmlspecialchars($data);
    return $data;
&#125;
?&gt;

&lt;h2&gt;PHP 表单验证实例&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;* 必需字段。&lt;/span&gt;&lt;/p&gt;
&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt; 
   名字: &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&lt;?php echo $name;?&gt;&quot;&gt;
   &lt;span class=&quot;error&quot;&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt;
   &lt;br&gt;&lt;br&gt;
   E-mail: &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;&lt;?php echo $email;?&gt;&quot;&gt;
   &lt;span class=&quot;error&quot;&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;
   &lt;br&gt;&lt;br&gt;
   网址: &lt;input type=&quot;text&quot; name=&quot;website&quot; value=&quot;&lt;?php echo $website;?&gt;&quot;&gt;
   &lt;span class=&quot;error&quot;&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;
   &lt;br&gt;&lt;br&gt;
   备注: &lt;textarea name=&quot;comment&quot; rows=&quot;5&quot; cols=&quot;40&quot;&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt;
   &lt;br&gt;&lt;br&gt;
   性别:
   &lt;input type=&quot;radio&quot; name=&quot;gender&quot; &lt;?php if (isset($gender) &amp;&amp; $gender==&quot;female&quot;) echo &quot;checked&quot;;?&gt;  value=&quot;female&quot;&gt;女
   &lt;input type=&quot;radio&quot; name=&quot;gender&quot; &lt;?php if (isset($gender) &amp;&amp; $gender==&quot;male&quot;) echo &quot;checked&quot;;?&gt;  value=&quot;male&quot;&gt;男
   &lt;span class=&quot;error&quot;&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt;
   &lt;br&gt;&lt;br&gt;
   &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot;&gt; 
&lt;/form&gt;

&lt;?php
echo &quot;&lt;h2&gt;您输入的内容是:&lt;/h2&gt;&quot;;
echo $name;
echo &quot;&lt;br&gt;&quot;;
echo $email;
echo &quot;&lt;br&gt;&quot;;
echo $website;
echo &quot;&lt;br&gt;&quot;;
echo $comment;
echo &quot;&lt;br&gt;&quot;;
echo $gender;



?&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/KMP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%A6-Prime%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/KMP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%A6-Prime%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP&动态规划&贪心算法…&Prime算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-06 13:43:53" itemprop="dateCreated datePublished" datetime="2022-01-06T13:43:53+08:00">2022-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 19:19:24" itemprop="dateModified" datetime="2022-01-07T19:19:24+08:00">2022-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>问题</strong></p>
<p>KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。</p>
<p><strong>代码实现</strong></p>
<pre><code>function KMPSearch(str1, str2, next)&#123;
    for(var i = 0, j = 0;i&lt;str1.length;i++)&#123;
        while(j&gt;0 &amp;&amp; str1[i] != str2[j])&#123;
            j = next[j-1];
        &#125;
        if(str1[i] == str2[j])&#123;
            j++;
        &#125;
        if(j == str2.length)&#123;
            return i-j+1;
        &#125;
    &#125;
    return -1;
&#125;
function KMPNext(dest)&#123;
    var next = new Array(dest.length);
    for(var i = 0;i&lt;dest.length;i++)&#123;
        dest[i] = 0;
    &#125;
    for(var i = 0, j = 0;i&lt;dest.length;i++)&#123;
        while(j&gt;0 &amp;&amp; dest[i]!=dest[j])&#123;
            j = next[j-1];
        &#125;
        if(dest[i] == dest[j])&#123;
            j++;
        &#125;
        next[i] = j;
    &#125;
    return next;
&#125;
</code></pre>
<p>#动态规划#<br><strong>背包问题</strong></p>
<p>背包问题：假如目前有三种物品：吉他、音响、电脑，他们的价值分别是1000、2000、2500，重量分别是1磅、3磅、2磅，背包的容量是固定值4磅，现在要把几种物品放进背包中使得在不超重的前提下背包的价值达到最大。<br>**代码实现    **</p>
<pre><code>function dynamic_planning()&#123;
    var val = [1000, 3000, 2500];
    var w = [1, 3, 2];
    var sum = 4;
    var v = new Array(w.length);
    for(var i = 0;i&lt;v.length;i++)&#123;
        v[i] = new Array(sum);
    &#125;
    for(i = 0;i&lt;v.length;i++)&#123;
        for(var j = 0;j&lt;sum;j++)&#123;
            v[i][j] = 0;
        &#125;
    &#125;
    for(i = 0;i&lt;v.length;i++)&#123;
        for(j = 0;j&lt;sum;j++)&#123;
            if(w[i-1]&gt;j)&#123;
                v[i][j] = v[i-1][j];
            &#125;
            else&#123;
                v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
            &#125;
        &#125;
    &#125;
        &#125;
</code></pre>
<h1 id="贪心算法（最佳应用：集合覆盖问题）"><a href="#贪心算法（最佳应用：集合覆盖问题）" class="headerlink" title="贪心算法（最佳应用：集合覆盖问题）"></a>贪心算法（最佳应用：集合覆盖问题）</h1><p><strong>概念：</strong>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。</p>
<p>*算法思路：</p>
<p>1）遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没关系）</p>
<p>2）将这个电台加入到一个集合中（比如ArrayList），想办法把电台覆盖的地区在下次比较时去掉。</p>
<p>3）重复第一步，直到覆盖了全部的地区。<br>Prim算法（应用场景：修路问题）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/Tree-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/Tree-Graph/" class="post-title-link" itemprop="url">Tree&Graph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:14:38 / Modified: 13:48:41" itemprop="dateCreated datePublished" datetime="2022-01-06T13:14:38+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的概念："><a href="#树的概念：" class="headerlink" title="树的概念："></a>树的概念：</h2><p>树是一种数据结构，它是由n(n≥1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h2 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h2><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。<br>树的特点：</p>
<p>由二叉树定义以及图示分析得出二叉树有以下特点：<br>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<br>性质：</p>
<p>1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）<br>2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）<br>3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p>
<p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br>(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；<br>(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>前序遍历，中序遍历，后序遍历。</p>
<p>前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。中序后序以此类推。</p>
<p><strong>//前序遍历</strong><br>    <script type="text/javascript"><br>            function TreeNode(val) {<br>              this.val = val;<br>              this.left = this.right = null;<br>             }</p>
<pre><code>        function preorderTraversal(root)&#123;
            const res = [];
            function inorder(root) &#123;
                if(root==null)
                    return;
                res.push(root.val);
                inorder(root.left);//递归
                inorder(root.right);
            &#125;
            inorder(root);

        &#125;
&lt;/script&gt;
</code></pre>
<p><strong>//中序遍历</strong><br>    function inorderTraversal(root){<br>        const res = [];<br>        function inorder(root) {<br>            if(root==null)<br>                return;<br>            inorder(root.left);//递归<br>            res.push(root.val);<br>            inorder(root.right);<br>        }</p>
<p><strong>//后序遍历</strong><br>    function postorderTraversal(root){<br>        const res = [];<br>        function inorder(root) {<br>            if(root==null)<br>                return;<br>            inorder(root.left);//递归<br>            inorder(root.right);<br>            res.push(root.val);<br>        }</p>
<h2 id="二叉树结点删除"><a href="#二叉树结点删除" class="headerlink" title="二叉树结点删除"></a>二叉树结点删除</h2><p>规定：</p>
<p>1）如果删除的节点是叶子节点，则删除该节点</p>
<p>2）如果删除的节点是非叶子节点，则删除该子树</p>
<p>思路：</p>
<p>1）考虑树是空树root。那么只有一个root节点，则等价将二叉树置空。</p>
<p>2）因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否删除节点，而不能去判断当前节点是不是需要删除节点。</p>
<p>3）如果当前节点的左子节点不为空，并且左子节点就是需要删除节点，就将this.left = null，并且就返回（结束递归删除）</p>
<p>4）如果当前节点的右子节点不为空，并且右子节点就是需要删除节点，就将this.right= null，并且就返回（结束递归删除）</p>
<p>5）如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除</p>
<p>6）如果第4步没有删除节点，则应当向右子树进行递归删除。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>(引自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42126431/article/details/89537923">https://blog.csdn.net/weixin_42126431/article/details/89537923</a>)<br>图的相关术语</p>
<p>1.1.有一条边相连的顶点叫相邻顶点；<br>1.2.一个顶点的度就是该顶点的相邻顶点数；<br>1.3.路径指顶点组成的连续序列；<br>1.4.简单路径没有重复顶点；<br>1.5.有向图和无向图<br>图的表示<br>邻接矩阵</p>
<p>array[i][j] ===1代表i节点和j节点相邻，否则不相邻<br>邻接表</p>
<p>相当于把每个节点的相邻节点一一列举出来。<br>关联矩阵</p>
<p>形式和邻接矩阵一样，只是把邻接矩阵的直接维度换成对应的边，适用于边比顶点多的情况。<br>创建图类</p>
<p>接下来就采用邻接表的方式创建上面的图并且采用字典来表示：</p>
<p>创建字典类    </p>
<p> //创建字典类<br>    function Dictionary(){<br>        var items = {};</p>
<pre><code>    //set(key,value)向字典里添加新元素，这里主要用来添加边
    this.set = function(key,value)&#123;
        items[key] = value;
    &#125;

    //has(key)如果存在就返回true，否则false
    this.has = function(key)&#123;
        return key in items;
    &#125;

    //get(key)通过key查找特定的数值并返回，这里主要用来查找顶点对应的边数组
    this.get = function(key)&#123;
        return this.has(key) ? items[key] : undefined;
    &#125;
&#125;
</code></pre>
<p>创建图类    </p>
<p>//创建图类Graph()<br>    function Graph(){<br>        var vertices = [];    //用来储存顶点<br>        var adjList = new Dictionary();    //用来储存边</p>
<pre><code>    //创建initializeColor用来初始化各个顶点的颜色，为遍历过程中的标记做准备
    var initializeColor = function()&#123;
        var color = [];
        for (var i=0; i&lt;vertices.length; i++)&#123;
            color[vertices[i]] = &#39;white&#39;;
        &#125;
        return color;
    &#125;
    
    //addVertex(key)用来添加顶点
    this.addVertex = function(v)&#123;
        vertices.push(v);
        adjList.set(v, []);
    &#125;

    //addEdge(key,value)用来添加边v-w
    this.addEdge = function(v,w)&#123;
        adjList.get(v).push(w);
        adjList.get(w).push(v);
    &#125;

    //toString()把邻接表转化成字符串的形式，便于输出显示
    this.toString = function()&#123;
        var s = &#39;&#39;;
        for(var i=0; i&lt;vertices.length; i++)&#123;
            s += vertices[i] + &#39;-&gt;&#39;;
            var neighbors = adjList.get(vertices[i]);
            for(var j=0; j&lt;neighbors.length; j++)&#123;
                s += neighbors[j] + &#39; &#39;;
            &#125;
            s += &#39;\n&#39;;
        &#125;
        return s;
    &#125;
&#125;
</code></pre>
<p>创建实例<br>//创建实例<br>    var graph = new Graph();<br>    var myVertices = [‘A’,’B’,’C’,’D’,’E’,’F’,’G’,’H’,’I’];<br>    //添加顶点<br>    for(var i=0; i&lt;myVertices.length; i++){<br>        graph.addVertex(myVertices[i]);<br>    }<br>//逐一加入边<br>    graph.addEdge(‘A’,’B’);<br>    graph.addEdge(‘A’,’C’);<br>    graph.addEdge(‘A’,’D’);<br>    graph.addEdge(‘C’,’G’);<br>    graph.addEdge(‘C’,’D’);<br>    graph.addEdge(‘D’,’G’);<br>    graph.addEdge(‘D’,’H’);<br>    graph.addEdge(‘B’,’E’);<br>    graph.addEdge(‘B’,’F’);<br>    graph.addEdge(‘E’,’I’);<br>    console.log(graph.toString());</p>
<p>输出的结果为：<br>A-&gt;B C D<br>B-&gt;A E F<br>C-&gt;A G D<br>D-&gt;A C G H<br>E-&gt;B I<br>F-&gt;B<br>G-&gt;C D<br>H-&gt;D<br>I-&gt;E </p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>采用队列的方式，先添加节点的先被探索；<br>采用三种颜色来反应节点的状态：<br>白色：还没被访问；<br>灰色：被访问但未被探索；<br>黑色：被访问且探索过；<br>思路：</p>
<p>首先搜索节点A，探索A节点的相邻节点B,C,D,把其加入队列中，再逐一出队列进行探索，从而实现广度遍历。<br>添加bfs方法     </p>
<p>//广度优先遍历，在Graph()类中添加以下方法<br>    this.bfs = function(v, callback){<br>        var color = initializeColor();    //初始化节点，都标记为白色<br>        var queue = [];    //创建队列用来顶点的入队；<br>        queue.push(v);    //访问的节点入队列<br>        while(!queue.length==0){    //如果队列非空就执行以下<br>            var u = queue.shift();    //节点出队列<br>            var neighbors = adjList.get(u);  //探索节点对应的边<br>            color[u] = ‘grey’;    //把搜索过的节点变成灰色<br>            for (var i=0; i&lt;neighbors.length; i++){<br>                var w = neighbors[i];<br>                if(color[w] === ‘white’){    //如果探索到的子节点是白色就逐一变灰并入队列<br>                    color[w] = ‘grey’;<br>                    queue.push(w);<br>                }<br>            }<br>            color[u] = ‘black’;        //节点完成搜索和探索的过程，直接变黑<br>            if(callback){<br>                callback(u);        //回调函数，可以用来输出<br>            }<br>        }<br>    }</p>
<p>创建bfs实例<br>//bfs实例<br>    function printNode(value){<br>        console.log(‘Visited vertex:’+value);<br>    }<br>    graph.bfs(myVertices[0],printNode);</p>
<p>bfs输出结果<br>Visited vertex:A<br>Visited vertex:B<br>Visited vertex:C<br>Visited vertex:D<br>Visited vertex:E<br>Visited vertex:F<br>Visited vertex:G<br>Visited vertex:H<br>Visited vertex:I</p>
<p>使用BFS寻找最短路径<br>    this.BFS = function(v){<br>            var color = initializeColor(),<br>            queue = [],<br>            d = [],    //用来储存从v到u的距离<br>            pred = [];    //用来储存节点的前溯点<br>            queue.push(v);</p>
<pre><code>        for(var i=0; i&lt;vertices.length; i++)&#123;
            d[vertices[i]] = 0;        //初始化
            pred[vertices[i]] = null;
        &#125;

        while(!queue.length == 0)&#123;
            var u = queue.shift();
            var neighbors = adjList.get(u);
            color[u] = &#39;grey&#39;;
            for (i=0; i&lt;neighbors.length; i++)&#123;
                var w = neighbors[i];
                if(color[w] === &#39;white&#39;)&#123;
                    color[w] = &#39;grey&#39;;
                    d[w] = d[u]+1;    //从头节点到w的距离
                    pred[w] = u;
                    queue.push(w);
                &#125;
            &#125; 
            color[u] = &#39;black&#39;;
        &#125;
        return&#123;
            distance:d,
            predecessers:pred
        &#125;
    &#125;
</code></pre>
<p>创建BFS实例<br>//BFS实例<br>    var shortestPathA = graph.BFS(myVertices[0]);//需要输入头节点myVertice[0]<br>    //console.log(shortestPathA);</p>
<p>//搜索路径BFS<br>    var fromVertex = myVertices[0];<br>    for (var i=1; i&lt;myVertices.length; i++){<br>        var toVertex = myVertices[i];<br>        var path = [];    //path用来储存路径<br>        for (var v=toVertex; v!==fromVertex; v=shortestPathA.predecessers[v]){<br>            path.push(v);<br>        }<br>        path.push(fromVertex);<br>        var s = path.pop();<br>        while(!path.length==0){<br>            s += ‘-‘ + path.pop();<br>        }<br>        console.log(s)<br>    }</p>
<p>BFS输出结果<br>A-B<br>A-C<br>A-D<br>A-B-E<br>A-B-F<br>A-C-G<br>A-D-H<br>A-B-E-I</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>采用栈的方式，先添加节点的先被探索；<br>由递归实现。<br>思路：</p>
<p>从节点A开始，探索到A的相邻节点B,C,D压入栈中（这里的代码采用for循环，所以没有实质上的栈，但是用栈更容易理解），接着搜索B，探索到B的相邻节点E,F压入栈中，以此递归。<br>添加dfs方法<br>    this.dfs = function(callback){<br>            var color = initializeColor();<br>            for (var i=0; i&lt;vertices.length; i++){<br>                if(color[vertices[i]]===’white’){<br>                    dfsVisit(vertices[i], color, callback)//调用递归函数<br>                }<br>            }<br>        }</p>
<pre><code>    var dfsVisit = function(u, color, callback)&#123;
        color[u] = &#39;grey&#39;;
        if(callback)&#123;
            callback(u);
        &#125;
        var neighbors = adjList.get(u);
        for(var i=0; i&lt;neighbors.length; i++)&#123;
            var w = neighbors[i];
            if(color[w] === &#39;white&#39;)&#123;
                dfsVisit(w, color, callback);
            &#125;
        &#125;
        color[u] = &#39;black&#39;;
    &#125;
</code></pre>
<p>创建dfs实例</p>
<p>graph.dfs(printNode);</p>
<p>dfs输出结果<br>Visited vertex:A<br>Visited vertex:B<br>Visited vertex:E<br>Visited vertex:I<br>Visited vertex:F<br>Visited vertex:C<br>Visited vertex:G<br>Visited vertex:D<br>Visited vertex:H</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/sort/" class="post-title-link" itemprop="url">sort</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-06 13:07:46" itemprop="dateCreated datePublished" datetime="2022-01-06T13:07:46+08:00">2022-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 19:21:39" itemprop="dateModified" datetime="2022-01-07T19:21:39+08:00">2022-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bubble-Sorting"><a href="#Bubble-Sorting" class="headerlink" title="Bubble Sorting"></a>Bubble Sorting</h1><p>冒泡排序：（Bubble Sorting）：通过对待排序序列从前向后（从下标较小的元素开始）通过依次比较相邻的元素的值，若发现逆序则交换，使值较大的元素逐渐从前向后移动，就像水底的气泡一样逐渐网上冒。</p>
<pre><code>function bubbleSort(arr) &#123;
    var i = arr.length, j;
    var tempExchangVal;
    while (i &gt; 0) &#123;
        for (j = 0; j &lt; i - 1; j++) &#123;
            if (arr[j] &gt; arr[j + 1]) &#123;
                tempExchangVal = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tempExchangVal;
            &#125;
        &#125;
        i--;
    &#125;
    return arr;
&#125;

var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];
var arrSorted = bubbleSort(arr);
console.log(arrSorted);
alert(arrSorted);
</code></pre>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><strong>算法描述：</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<p>初始状态：无序区为R[1…n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p>
<pre><code>function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125; 
</code></pre>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>代码中定义了两个指针：currentIndex，preIndex。</p>
<pre><code>var currentIndex, preIndex, value;
for(var i = 1;i&lt;arr.length;i++)
&#123;
    currentIndex = i;
    preIndex = i-1;
    value = arr[currentIndex];
    while(value&lt;arr[preIndex] &amp;&amp; preIndex&gt;=0)
    &#123;
        arr[currentIndex] = arr[preIndex];
        currentIndex = preIndex;
        preIndex--;
    &#125;
    arr[preIndex+1] = value;
&#125;
return arr;
&#125;
var arr = [-1, 2, 5, 9, 1, 5, 7, 6, 8];
var arrSorted = InsertSort(arr);
console.log(arrSorted);
alert(arrSorted);
</code></pre>
<h1 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h1><p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p><strong>算法描述：</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
</li>
<li><p>按增量序列个数k，对序列进行k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p> function ShellSort(arr) {</p>
<pre><code>         var k = 0;
         for(var gap = Math.floor(arr.length/2 ); gap&gt;=1; Math.floor(gap /= 2))
         &#123;
             k =0;
             while(k&lt;arr.length-gap)
             &#123;
                 if(arr[k]&gt;arr[k+gap])
                 &#123;
                     t = arr[k];
                     arr[k] = arr[k+gap];
                     arr[k+gap] = t;
                 &#125;
                 k++;
             &#125;
         &#125;
         return arr;
     &#125;
</code></pre>
</li>
</ol>
<h1 id="归并排序（merge-sorting）"><a href="#归并排序（merge-sorting）" class="headerlink" title="归并排序（merge sorting）"></a>归并排序（merge sorting）</h1><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br><strong>算法描述：</strong></p>
<ol>
<li><p>把长度为n的输入序列分成两个长度为n/2的子序列；</p>
</li>
<li><p>对这两个子序列分别采用归并排序；</p>
</li>
<li><p>将两个排序好的子序列合并成一个最终的排序序列。</p>
<p> function MergeSorting(arr) {</p>
<pre><code> if(arr.length&lt;2)
     return arr;
 var middle = Math.floor(arr.length/2);
 var left = arr.slice(0, middle);
 var right = arr.slice(middle, arr.length);
 return Merge(MergeSorting(left), MergeSorting(right));
     &#125;
</code></pre>
<p> function Merge(left, right){</p>
<pre><code> var result = [];
 while(left.length&gt;0&amp;&amp;right.length&gt;0)&#123;
     if(left[0]&gt;right[0])
     &#123;
         result.push(right.shift());
     &#125;
     else&#123;
         result.push((left.shift()))
     &#125;&#125;
 while(left.length)&#123;
     result.push(left.shift());
 &#125;
 while(right.length)&#123;
     result.push(right.shift());
 &#125;


 return result;
</code></pre>
<p> }</p>
</li>
</ol>
<h1 id="快速排序（quick-sorting）"><a href="#快速排序（quick-sorting）" class="headerlink" title="快速排序（quick sorting）"></a>快速排序（quick sorting）</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br><strong>算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）；</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <title>bottom</title>
     <script type="text/javascript">
         function quicksort(arr, left, right){
             var l = left;
             var r = right;
             var pivot = arr[Math.floor((left+right)/2)];
             while (l<r){
                 while(arr[l]<pivot){
                     l++;
                 }
                 while(arr[r]>pivot){
                     r--;
                 }
                 if(l>=r){
                     break;
                 }
                 var temp = arr[l];
                 arr[l] = arr[r];
                 arr[r] = temp;
                 if(arr[l] == pivot){
                     r--;
                 }
                 if(arr[r]==pivot){
                     l++;
                 }
             }
             if(l==r){//防止栈溢出
                 l++;
                 r--;
             }
             if(left<r){//向左递归
                 quicksort(arr, left, r);
             }
             if(right>l){//向右递归
                 quicksort(arr, l, right);
             }
 
<pre><code>     &#125;
     var arr = [1,2,-1,5,7,3,0];
     quicksort(arr, 0, arr.length-1);
     alert(arr);
 &lt;/script&gt;
</code></pre>
 </head>
 <body>
     我是bottom；
 </body>
 </html></li>
</ol>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。<br><strong>算法描述</strong></p>
<ol>
<li><p>设置一个定量的数组当作空桶；</p>
</li>
<li><p>遍历输入数据，并且把数据一个一个放到对应的桶里去；</p>
</li>
<li><p>对每个不是空的桶进行排序；</p>
</li>
<li><p>从不是空的桶里把排好序的数据拼接起来。</p>
<p> function BucketSorting(arr){</p>
<pre><code> var maxvalue = arr[0];
 for(var i = 1; i&lt;arr.length;i++)&#123;
     if(maxvalue&lt;arr[i])&#123;
         maxvalue = arr[i];
     &#125;
 &#125;
 var maxlen = (maxvalue + &quot;&quot;).length;
 for(var i = 0,n = 1;i&lt;maxlen;i++,n*=10)&#123;
     var takenvalue;
     var returnResult = new Array();
     for (var k = 0; k&lt;10;k++)&#123;
         returnResult[i]=[];
     &#125;
     var arrlen = new Array(10);
     for(var j = 0;j&lt;arr.length;j++)&#123;
         takenvalue = Math.floor(arr[j]/n%10);
         alert(typeof arr[j]);
         returnResult[takenvalue].push(arr[j]);
         arrlen[takenvalue] += 1;
     &#125;
     var index = 0;
     for(var k = 0;k&lt;10;k++)&#123;
         if(arrlen[k]&gt;0)&#123;
             for(var m = 0;m&lt;arrlen[k];m++)
                 arr[index++] = returnResult[k][m];
         &#125;
     &#125;
 &#125;
 return arr;
     &#125;
</code></pre>
</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。升序，大顶堆；降序，小顶堆。<br>算法描述</p>
<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
<pre><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) &#123;   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;
 
function heapify(arr, i) &#123;     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;
 
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;
 
    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;
 
function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
 
function heapSort(arr) &#123;
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;
</code></pre>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/jQuery-bootstrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/jQuery-bootstrap/" class="post-title-link" itemprop="url">jQuery&bootstrap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:03:18 / Modified: 13:07:18" itemprop="dateCreated datePublished" datetime="2022-01-06T13:03:18+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h1><pre><code>jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。

基础语法： $(*selector*).*action*()

    美元符号定义 jQuery
    选择符（selector）“查询&quot;和&quot;查找” HTML 元素
    jQuery 的 action() 执行对元素的操作

实例:

    $(this).hide() - 隐藏当前元素
    $(“p”).hide() - 隐藏所有

    元素
    $(“p.test”).hide() - 隐藏所有 class=“test” 的

    元素
    $(“#test”).hide() - 隐藏 id=“test” 的元素

文档就绪事件

您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：
$(document).ready(function()&#123;
 // 开始写 jQuery 代码...  
        &#125;);

这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。

如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：

    试图隐藏一个不存在的元素
    获得未完全加载的图像的大小

**提示：**简洁写法（与以上写法效果相同）:    

$(function()&#123;
    // 开始写 jQuery 代码...  
        &#125;);

以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。
</code></pre>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><pre><code>jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。

jQuery 选择器基于元素的 id、类、类型、属性、属性值等&quot;查找&quot;（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。

jQuery 中所有选择器都以美元符号开头：$()。

元素选择器

jQuery 元素选择器基于元素名选取元素。

在页面中选取所有

元素:    

$(&quot;p&quot;)
</code></pre>
<h2 id="id-选择器"><a href="#id-选择器" class="headerlink" title="#id 选择器"></a>#id 选择器</h2><pre><code>jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。

页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。

通过 id 选取元素语法如下：


$(&quot;#test&quot;)

.class 选择器

jQuery 类选择器可以通过指定的 class 查找元素。

语法如下：


$(&quot;.test&quot;)
</code></pre>
<h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><pre><code>页面对不同访问者的响应叫做事件。

事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。

实例：

    在元素上移动鼠标。
    选取单选按钮
    点击元素
</code></pre>
<h2 id="click"><a href="#click" class="headerlink" title="click()"></a>click()</h2><p>click() 方法是当按钮点击事件被触发时会调用一个函数。</p>
<p>该函数在用户点击 HTML 元素时执行。</p>
<p>在下面的实例中，当点击事件在某个</p>
<p>元素上触发时，隐藏当前的</p>
<p>元素：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
    &lt;/script&gt;
    &lt;script&gt;
        $(function()&#123;
            $(&quot;p&quot;).click(function()&#123;
                $(this).hide();
                        &#125;)&#125;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt;
    &lt;p&gt;继续点我!&lt;/p&gt;
    &lt;p&gt;接着点我!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>dblclick() – 鼠标双击事件， mouseenter() – 当鼠标指针穿过元素， mouseleave() – 当鼠标指针离开元素</p>
<p>，mousedown() – 当鼠标指针移动到元素上方，并按下鼠标按键，等等。</p>
<p>jQuery Fading 方法：</p>
<p>通过 jQuery，您可以实现元素的淡入淡出效果。</p>
<p>jQuery 拥有下面四种 fade 方法：</p>
<pre><code>    fadeIn()
    fadeOut()
    fadeToggle()
    fadeTo()
</code></pre>
<h2 id="jQuery动画–animate-方法"><a href="#jQuery动画–animate-方法" class="headerlink" title="jQuery动画–animate() 方法"></a>jQuery动画–animate() 方法</h2><p>jQuery animate() 方法用于创建自定义动画。</p>
<p>语法：</p>
<p>$(selector).animate({params},speed,callback);</p>
<p>必需的 params 参数定义形成动画的 CSS 属性。</p>
<p>可选的 speed 参数规定效果的时长。它可以取以下值：“slow”、“fast” 或毫秒。</p>
<p>可选的 callback 参数是动画完成后所执行的函数名称。<br>    <!DOCTYPE html><br>    <html><br>    <head><br>        <meta charset="utf-8"><br>        <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"><br>        </script><br>        <script><br>            $(document).ready(function(){<br>                $("button").click(function(){<br>                    $("div").animate({left:'250px'});<br>                });<br>            });<br>        </script><br>    </head></p>
<pre><code>&lt;body&gt;
&lt;button&gt;开始动画&lt;/button&gt;
&lt;p&gt;默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。
    如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!&lt;/p&gt;
&lt;div style=&quot;background:#98bf21;height:100px;width:100px;position:absolute;&quot;&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="我的第一个用了-boostrap-https-v3-bootcss-com-的代码："><a href="#我的第一个用了-boostrap-https-v3-bootcss-com-的代码：" class="headerlink" title="我的第一个用了[boostrap][https://v3.bootcss.com]的代码："></a>我的第一个用了[boostrap][<a href="https://v3.bootcss.com]的代码：">https://v3.bootcss.com]的代码：</a></h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;Bootstrap 实例 - 响应式的列重置&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

   &lt;div class = &quot;container&quot;&gt;&lt;!--      .container 类用于固定宽度并支持响应式布局的容器--&gt;
      123
   &lt;/div&gt;
   &lt;div class=&quot;container-fluid&quot;&gt; &lt;!--      .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。--&gt;
      456
   &lt;/div&gt;
   &lt;table class=&quot;table table-bordered&quot;&gt;&lt;!--      添加 .table-bordered 类为表格和其中的每个单元格增加边框。--&gt;
      &lt;tr&gt;
         &lt;td&gt;姓名&lt;/td&gt;
         &lt;td&gt;科目&lt;/td&gt;
         &lt;td&gt;成绩&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;夏明&lt;/td&gt;
         &lt;td&gt;数学&lt;/td&gt;
         &lt;td&gt;149&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;徐雪&lt;/td&gt;
         &lt;td&gt;英语&lt;/td&gt;
         &lt;td&gt;139&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>要使用boostrap，下面这些代码是必须要添加上的：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
&lt;/div&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/css/" class="post-title-link" itemprop="url">css</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:00:02 / Modified: 14:01:34" itemprop="dateCreated datePublished" datetime="2022-01-06T13:00:02+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p><strong>css的选择器学习</strong>：<br>    <style type = "text/css"><br>            /<em>标签选择器</em>/<br>            table{<br>                height: 300px;<br>                width: 200px;<br>                border: solid 1px;<br>                background-color: red;<br>            }<br>            /<em>id选择器</em>/<br>            #t1{<br>                background-color: blue;<br>            }<br>            /<em>类选择器</em>/<br>            .common{<br>                color:red;<br>            }<br>            /<em>组合选择器</em>/<br>            table,.common{<br>                color:red;<br>            }<br>        </style></p>
<p><strong>标签选择器</strong>：标签名{样式名1：样式值1；…}</p>
<p><strong>作用</strong>：会将当前网页内所有该标签增加相同的样式</p>
<p><strong>id选择器</strong>：#标签的id属性值{样式名1：样式值1；…}</p>
<p><strong>作用</strong>：给某个指定的标签添加样式</p>
<p><strong>类选择器</strong>：.类选择器名{样式名1：样式值1；…}</p>
<p><strong>作用</strong>：给不同的标签添加相同的样式</p>
<p><strong>全部选择选择器</strong>：*{样式名1：样式值1；…}</p>
<p><strong>作用</strong>：选择所有的HTML标签，并添加相同的样式</p>
<p><strong>组合选择器</strong>：选择器1，选择器2，…{样式名1：样式值1；…}</p>
<p><strong>作用</strong>：解决不同的选择器之间重复样式的问题</p>
<h2 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;照片墙&lt;/title&gt;
    &lt;style type = &quot;text/css&quot;&gt;
        body&#123;
            text-align: center;
            background-color: gray;
        &#125;
        img&#123;
            width: 20%;/*设置高度*/
            padding: 10px;/*设置内边距*/
            background-color: white;/*设置背景颜色*/
            transform: rotate(-10deg);/*设置倾斜角度*/
            margin-left: 10px;/*设置外边距*/
        &#125;
        img:hover&#123;
            transform: rotate(0deg) scale(1.5);/*设置倾斜角度和缩放比例*/
            z-index: 2;/*    设置显示优先级别*/
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=652732258,3535184171&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=3459544028,1422320751&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://img1.baidu.com/it/u=3806063294,3480903396&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=121804161,3053314887&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;br/&gt;&lt;br/&gt;
    &lt;img src=&quot;https://img2.baidu.com/it/u=3108583535,4104247024&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=640&amp;h=360&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://img0.baidu.com/it/u=2135482323,1459336928&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw500h280%2F20171219%2F13f2-fypvuqe0957796.gif&amp;refer=http%3A%2F%2Fn.sinaimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1636370856&amp;t=e55fc69178ee867433ab3e74c60adbf2&quot; alt=&quot;&quot;/&gt;
    &lt;img src=&quot;https://img2.baidu.com/it/u=2414916686,3188715239&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt;
    &lt;hr/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><strong>外边距</strong>：margin</p>
<p><strong>作用</strong>：用来设置元素与元素之间的间隔</p>
<p>居中设置：margin：0px auto；上下间隔是0px，水平居中。</p>
<p>边框：border</p>
<p>作用：用来设置元素的边框大小，可以单独设置上下左右</p>
<p>内边距：padding</p>
<p>作用：设置内容与边框之间的距离，内边距不会改变内容区域的大小，可以单独设置上下左右的内边距</p>
<p>内容区域：改变内容区域的大小，设置宽和高即可改变内容区域的大小。<br>    <!DOCTYPE html><br>    <html lang="en"><br>    <head><br>        <meta charset="UTF-8"><br>        <title>盒子模型</title><br>        <style type = "text/css"><br>            div{<br>                width: 300px;<br>                height: 300px;<br>            }<br>            #div01{<br>                border: solid 1px orange;<br>            }<br>            #div02{<br>                border:solid 1px blueviolet;<br>            }<br>            #div03{<br>                border:solid 1px aqua;<br>            }<br>            #div04{<br>                border:bisque;<br>            }<br>        </style><br>    </head><br>    <body></p>
<pre><code>    &lt;div id = &quot;div01&quot;&gt;
        我是div01
    &lt;/div&gt;
    &lt;div id = &quot;div02&quot;&gt;
        我是div02
    &lt;/div&gt;
    &lt;div id = &quot;div03&quot;&gt;
        我是div03
    &lt;/div&gt;
    &lt;div id = &quot;div04&quot;&gt;
        我是div04
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>CSS模块<br>边框</p>
<p>边框属性：</p>
<p>border-radius 用于创建圆角<br>box-shadow 用来添加阴影<br>border-image 属性允许你指定一个图片作为边框，用于创建上文边框的原始图像</p>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
    &lt;style&gt;
        #test&#123;
            width:300px;
            height: 100px;
            padding: 1px;
            border: 2px solid #00a0ff;
            border-radius: 25px;
            background-image: url(&quot;https://img0.baidu.com/it/u=280905735,1446098188&amp;fm=26&amp;fmt=auto&quot;);
            box-shadow: 10px 10px 10px aqua;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id = &quot;test&quot;&gt;
    这是一道美丽的风景线
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="css背景"><a href="#css背景" class="headerlink" title="css背景"></a>css背景</h2><p>background-image 添加背景图片，不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<p>background-sizebackground-size 指定背景图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。</p>
<p>CSS3中可以指定背景图片，让我们重新在不同的环境中指定背景图片的大小。您可以指定像素或百分比大小。你指定的大小是相对于父元素的宽度和高度的百分比的大小。</p>
<p>background-origin</p>
<p>background-clip</p>
<p>这部分内容很有意思，要自己去试试，我就不介绍全部的细节了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/html/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/html/" class="post-title-link" itemprop="url">html</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 12:55:25 / Modified: 13:56:21" itemprop="dateCreated datePublished" datetime="2022-01-06T12:55:25+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTML基础学习"><a href="#HTML基础学习" class="headerlink" title="HTML基础学习"></a>HTML基础学习</h1><h2 id="body-标签"><a href="#body-标签" class="headerlink" title="body 标签"></a>body 标签</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 aligh = &quot;left&quot;&gt;
    全红禅祝大家国庆节快乐！
&lt;/h1&gt;

&lt;hr width = &quot;20%&quot; size = 5px color = &quot;purple&quot;/&gt;
&lt;p&gt;
    全红婵发文祝大家国庆节快乐，并且晒出长隆假期游玩照，准备恢复挥汗如雨的训练生活了，妹妹玩得开心啊! 妹妹真的太可爱了!
&lt;/p&gt;
    哈哈哈，&lt;b&gt;全红婵&lt;/b&gt;妹妹有心啦！特意发文祝大家国庆节快乐！还真是个体贴又温暖的&lt;i&gt;女孩呢！&lt;/i&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你也要快乐过节，&lt;u&gt;快乐训练！&lt;/u&gt;期待你下次精彩表现。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>标题标签</strong>： h1到h6：将其中的内容加粗加黑显示，并且显示依次减弱，自带换行功能（块级标签）。</p>
<p><strong>属性</strong>：aligh = “center”/ “left”/“right”</p>
<p><strong>水平线标签</strong>：hr 在页面中显示一条水平线，默认居中显示</p>
<p><strong>属性</strong>：</p>
<ul>
<li><p>width = “宽度” 设置水平线的宽度</p>
</li>
<li><p>size = “高度” 设置水平线的高度</p>
</li>
<li><p>color = “颜色” 设置水平线的颜色</p>
</li>
</ul>
<p><strong>段落标签</strong>：p 会将一段数据作为整体进行显示自动换行，段间距比较大</p>
<p><strong>换行符</strong>：br 告诉浏览器在此位置增加空格</p>
<p><strong>权重标签</strong>： </p>
<ul>
<li><p>b 会将内容加黑显示</p>
</li>
<li><p>i 会将内容斜体显示</p>
</li>
<li><p>u 会将内容增加下划线</p>
</li>
<li><p>del 增加中划线</p>
<h2 id="表单学习"><a href="#表单学习" class="headerlink" title="表单学习"></a>表单学习</h2>  <table border="1px" cellspacing="0px" cellpadding="8px">
      <tr height = "27px">
          <td colspan="5">基本情况</td>
      </tr>
      <tr height = "27px">
          <td width = "120px">姓名</td>
          <td width = "120px"></td>
          <td width = "120px">性别</td>
          <td width = "120px"></td>
          <td width = "120px" rowspan="7"></td>
      </tr>
      <tr height = "27px">
          <td>民族</td>
          <td></td>
          <td>出生年月</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>政治面貌</td>
          <td></td>
          <td>健康</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>籍贯</td>
          <td></td>
          <td>学历</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>电子信箱</td>
          <td></td>
          <td>联系电话</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>专业</td>
          <td colspan="3"></td>
      </tr>
      <tr height = "27px">
          <td>毕业院校</td>
          <td colspan="3"></td>
      </tr>
      <tr height = "27px">
          <td>求职意向</td>
          <td colspan="4"></td>
      </tr>
  </table></li>
</ul>
<ul>
<li><p>table：声明一个表格</p>
</li>
<li><p>tr：声明一行，设置行高以及该行所有单元格的高度</p>
</li>
<li><p>th：声明一个单元格，表头格，默认居中加黑显示</p>
</li>
<li><p>td：声明一个单元格，默认居左显示原始数据</p>
</li>
<li></li>
</ul>
<p><strong>注意</strong>：行高即该行所有单元格的宽度，单元格的宽度即列宽</p>
<p><strong>简单写法</strong>：五行六列的表格</p>
<pre><code>table&gt;tr*5&gt;td*6
</code></pre>
<p><strong>属性</strong>：</p>
<ul>
<li><p>border：给表格添加边框</p>
</li>
<li><p>width：设置表格的宽度</p>
</li>
<li><p>height：设置表格的高度</p>
</li>
<li><p>cellpadding：设置内容居边框的距离</p>
</li>
<li><p>cellspacing：设置边框的大小</p>
</li>
</ul>
<p><strong>单元格合并</strong>：</p>
<ol>
<li>首先确保表格是一个规整的表格</li>
<li>根据要合并的单元格，找到其所在的源码位置</li>
<li>行合并：在要合并的单元格中第一个单元格上使用属性rowspan=“要合并的单元格的个数”，并删除其他单元格完成合并</li>
</ol>
<p>列合并：在要合并的单元格中任意一个上使用属性colspan = “要合并的单元格的个数”并删除其他要合并的单元格完成合并</p>
<h2 id="内嵌标签学习"><a href="#内嵌标签学习" class="headerlink" title="内嵌标签学习"></a>内嵌标签学习</h2><p><strong>内嵌标签</strong>：iframe</p>
<ul>
<li><p>src：要显示的网页资源路径，可以是本地（相对路径）也可以是网络资源（URL），默认当前页面打开及加载src指向的资源</p>
</li>
<li><p>width：设置区域的宽度</p>
</li>
<li><p>height：设置区域的高度</p>
</li>
<li><p>form表单标签</p>
</li>
</ul>
<p>作用：收集并提交用户数据给指定服务器。</p>
<p>注意：form标签会收集其标签内部的数据，要提交的表单项必须拥有name属性，否则不会提交</p>
<h2 id="属性："><a href="#属性：" class="headerlink" title="属性："></a><strong>属性</strong>：</h2><ul>
<li><p>action：收集的数据的提交地址，URL</p>
</li>
<li><p>method：收集的数据的提交方式，</p>
</li>
<li><p>get：适合小量数据，表单数据以？隔开拼接在用户书写的URL后面，不同的键值对用&amp;连接，不安全。</p>
</li>
<li><p>post：适合大量数据，安全，隐式提交。</p>
</li>
<li><p>表单域标签：作用：给用户提供可以进行数据书写或者选择的标签，</p>
</li>
<li><p>文本框：input：</p>
</li>
</ul>
<p><strong>type</strong>：</p>
<ul>
<li><p>text 收集少量文本数据，用户可见</p>
</li>
<li><p>password 收集用户密码数据</p>
</li>
<li><p>name：数据提交的键，也会被js使用</p>
</li>
<li><p>value：默认值</p>
</li>
</ul>
<p><strong>单选框</strong>：type = “radio”，name属性相同的只能选一项数据 value 要提交的数据，checked checked使用此属性的单选默认是选择状态</p>
<p><strong>form表单标签</strong>：form标签会将其内部所有的form表单标签中的所有的用户数据按照method指定的提交方式提交给action指明的地址</p>
<pre><code>&lt;form action = &#39;#&#39; method=&quot;get&quot;&gt;
    用户名&lt;input type=&quot;text&quot; name = &quot;rtr&quot;/&gt;&lt;br/&gt;
    密码&lt;input type = &quot;text&quot; name = &quot;uid&quot;/&gt;&lt;br&gt;
    &lt;input type = &quot;submit&quot; value=&quot;提交&quot;/&gt;
    性别：男&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;male&quot; checked = &quot;checked&quot;/&gt;女&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;female&quot;/&gt;
&lt;/form&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/JS-Study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/JS-Study/" class="post-title-link" itemprop="url">JS Study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-06 12:44:56" itemprop="dateCreated datePublished" datetime="2022-01-06T12:44:56+08:00">2022-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-09 14:18:25" itemprop="dateModified" datetime="2022-01-09T14:18:25+08:00">2022-01-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>输出语句</strong></p>
<p>JavaScript 没有任何打印或者输出的函数。JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li><p>使用 window.alert() 弹出警告框。</p>
</li>
<li><p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
</li>
<li><p>使用 innerHTML 写入到 HTML 元素。</p>
</li>
<li><p>使用 console.log() 写入到浏览器的控制台。</p>
</li>
</ul>
<p>一个需要注意的点：return 语句，少写了return语句返回值会是undefined，在你得到输出的结果是undefined时要想到是不是少了return。<br><strong>for循环的使用</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;study&lt;/title&gt;
    &lt;script type = &quot;text/javascript&quot;&gt;
        for(var i = 10;i&lt;15;i++)
        &#123;
            document.write(i);
            document.write(&#39;&lt;br /&gt;&#39;);
        &#125;

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JS中的for循环与JAVA中的很相似，这里就不多说了。注意：JS中的换行符是    </p>
<pre><code>&lt;br /&gt;
</code></pre>
<p><strong>条件语句</strong></p>
<pre><code>if(age &gt;= 18)
&#123;
    console.log(age);
&#125;
</code></pre>
<p><strong>对象的属性</strong></p>
<pre><code>var obj = new Object();
obj.name = &quot;孙悟空&quot;;
obj.var = 798;
</code></pre>
<p>对象的属性名不强制要求遵守标识符的规范，但是我们使用时还是尽量按照标识符的规范去做。如果要使用特殊的属性名，不能采用.的方式来操作，使用：对象[“属性名”] = 属性值。</p>
<h4 id="JS的普通函数"><a href="#JS的普通函数" class="headerlink" title="JS的普通函数"></a>JS的普通函数</h4><p><strong>声明方式一：</strong></p>
<pre><code>function fun()
&#123;
    var sum = 0;
    for(var i = 0; i&lt;100; i++)
    &#123;
        sum += i;
    &#125;
    return sum
&#125;
alert(fun());
</code></pre>
<p><strong>声明方式二：</strong></p>
<pre><code>var fun = function()&#123;
            var sum = 0;
            for(var i = 0; i&lt;100; i++)
            &#123;
                sum += i;
            &#125;
            return sum
        &#125;
        alert(fun());
</code></pre>
<p><strong>箭头函数</strong><br>ES6标准新增了一种新的函数：Arrow Function（箭头函数）</p>
<pre><code>x =&gt; x * x
</code></pre>
<p>相当于：</p>
<pre><code>function (x) &#123;
    return x * x;
&#125;
</code></pre>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return：</p>
<pre><code>x =&gt; &#123;
    if (x &gt; 0) &#123;
        return x * x;
    &#125;
    else &#123;
        return - x * x;
    &#125;
&#125;
</code></pre>
<p>如果参数不是一个，就需要用括号()括起来：</p>
<pre><code>// 两个参数:
(x, y) =&gt; x * x + y * y

// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; &#123;
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) &#123;
        sum += rest[i];
    &#125;
    return sum;
&#125;
</code></pre>
<p><strong>JS的构造方法</strong></p>
<p>首先展示一个简单的代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;study&lt;/title&gt;
    &lt;script type = &quot;text/javascript&quot;&gt;
        function Person(name, age, gender)
        &#123;
            this.name = name;
            this.age = age;
            this.gender = gender;
            alert(&quot;Hello!&quot;);
            this.changeName=changeName;
            function changeName(name)
            &#123;
                this.lastname=name;
            &#125;//changeName() 函数 name 的值赋给 person 的 lastname 属性。 
        &#125;
        var Jogh = new Person(&quot;jogh&quot;, 12, &quot;male&quot;);// 如果 new 了函数内的 this 会指向当前这个 person 并且就算函数内部不 return 也会返回一个对象。

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在编写js代码的时候需要添加如下语句来声明这是一个JS代码块。    </p>
<pre><code>&lt;script type = &quot;text/javascript&quot;&gt;
&lt;/script&gt;
</code></pre>
<p>上述代码块中，Person是一个带参数的构造方法，this是指代该构造方法生成的对象；构造方法与普通方法不同之处在于构造方法调用的时候前面有一个关键字new。<br>原型prototype（重点）</p>
<p>在我们所创建的每一个函数，解析器都会函数添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype，这个对象没有任何作用。当函数以构造函数调用，他所创建的对象中都会有一个隐含的属性，通过__proto__来访问该属性。原型对象相当于一个公共的区域，所有的同一类的实例都可以访问到这个原型对象。</p>
<pre><code>function MyClass()
&#123;&#125;
function Person()
&#123;&#125;
var per = new Person();
MyClass.prototype == per.__proto__//true
</code></pre>
<p>程序中调试是测试，查找及减少bug(错误)的过程。</p>
<p>关键字let 和 const</p>
<p>ES6 可以使用 let 关键字来实现块级作用域。<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p>
<pre><code>&#123; 
    let x = 2;
&#125;
// 这里不能使用 x 变量
</code></pre>
<p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改：</p>
<pre><code>const PI = 3.141592653589793; PI = 3.14;      // 报错 PI = PI + 10;   // 报错
</code></pre>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 英文全称 JavaScript Object Notation；</p>
<p>JSON 是一种轻量级的数据交换格式；</p>
<p>JSON是独立的语言；</p>
<p>JSON 易于理解。</p>
<p>JSON 语法规则<br>数据为 键/值 对。<br>数据由逗号分隔。<br>大括号保存对象<br>方括号保存数组</p>
<h1 id="数组的基本操作-（Array）"><a href="#数组的基本操作-（Array）" class="headerlink" title="数组的基本操作 #（Array）"></a>数组的基本操作 #（Array）</h1><p>数组也是一个对象，不同的是普通的对象是使用字符串作为属性名，而数组是使用数字作为索引来操作元素。</p>
<p>数组长度没有限制，数组元素可以是数据类型。<br>数组创建：</p>
<pre><code>var arr = new Array();//使用构造函数创建数组，无参；
var arr0 = new Array(10, 20, 30);//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素间用，隔开；
var arr1 = new Array(10);//长度为10
var arr2 = [];
var arr3 = [1,2,3,4];
</code></pre>
<p>使用typeof检查一个数组时，会返回object。    </p>
<pre><code>console.log(typeof arr)//返回object
arr[0] = 10;//添加元素，索引是从0开始的整数。
console.log(arr.length)//获取数组的长度
</code></pre>
<h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><pre><code>arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;);//向数组末尾添加一个或者多个元素，并返回数组新的长度
arr.unshift(&quot;牛魔王&quot;);//向数组的开头添加一个或者多个元素，并返回新的数组长度

arr.pop();//删除数组最后一个元素，并将被删除的元素返回
arr.shift();//删除数组的第一个元素，并将被删除的元素返回
</code></pre>
<p>#数组遍历：#</p>
<pre><code>for(var i = 0;i&lt;arr.length;i++)
&#123;
    console.log(arr[i]);
&#125;
</code></pre>
<h3 id="forEach-这个方法只支持IE8以上的浏览器"><a href="#forEach-这个方法只支持IE8以上的浏览器" class="headerlink" title="forEach(这个方法只支持IE8以上的浏览器)"></a>forEach(这个方法只支持IE8以上的浏览器)</h3><pre><code>arr.forEach(function(a)&#123;
    console.log(&quot;hello&quot;);
    console.log(a);
    &#125;);
</code></pre>
<p>//像这种函数，由我们创建但不由我们调用，回调函数,数组中有几个元素就会执行几次。每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个就是当前正在遍历的元素，第二个参数是当前正在遍历元素的索引，第三个参数是正在遍历的数组对象</p>
<h3 id="slice-splice"><a href="#slice-splice" class="headerlink" title="slice|splice"></a>slice|splice</h3><pre><code>var result = arr.slice(0, 2);//截取开始位置的索引，截取结束位置的索引，包含开始不包含结束索引。该方法不会改变元素数组，而是将截取到的元素封装到一个新的数组中；第二个参数可以省略不写，此时会截取从开始索引往后的所有元素；索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1倒数第一个。
var result = arr.splice(0, 2, &quot;牛魔王&quot;);//可以用于删除数组中的指定元素，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回。第一个表示开始位置的索引，第二个表示删除的数量，第三个及以后的元素：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。
</code></pre>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><pre><code>var arr = [1,2,3,2,2,1,3,4,2,5];
for(var i = 0;i&lt;arr.length;i++)
&#123;
    for(var j = i+1;j&lt;arr.length;j++)
    &#123;
        if(arr[i] == arr[j])
        &#123;
            arr.splice(j, 1);
            //当删除了当前j所在的元素以后，后面的元素会自动补位。元素的长度也会跟着改变。
            j--;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="concat-join-reverse-sort"><a href="#concat-join-reverse-sort" class="headerlink" title="concat|join|reverse|sort"></a>concat|join|reverse|sort</h3><pre><code>var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;];
var arr2 = [&quot;白骨精&quot;,&quot;蜘蛛精&quot;]
result = arr.concat(arr2,&quot;牛魔王&quot;);//该方法可以连接两个或者多个数组，并将新的数组返回，不会对原数组产生影响
result = arr.join(&quot;@-@&quot;);//该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串返回，在join()中可以指定字符串作为参数，该参数会成为数组中的元素连接符，默认为&quot;,&quot;。
arr.reverse();//该方法用来反转数组，修改原数组
arr.sort();//用来对数组中的元素进行排序，修改原数组，默认会按照Unicode编码进行排序，即使对于纯数字的数组，可能会得到错误结果。添加回调函数，指定排序规则，回调函数中定义两个形参，a在b前面：
arr.sort(function(a,b)&#123;
         if(a&gt;b)
            return 1;
        else 
            return 0;
            &#125;);
arr.sort(function(a,b)&#123;
         return a-b;
            &#125;);
Math.min(...arr);获取数组中的最小值。
</code></pre>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><pre><code>array.indexOf 此方法判断数组中是否存在某个值，如果存在返回数组元素的下标，否则返回-1
let arr = [&#39;something&#39;, &#39;anything&#39;, &#39;nothing&#39;, &#39;anything&#39;];let index = arr.indexOf(&#39;nothing&#39;);console.log(index) //结果是2
</code></pre>
<p>省略号</p>
<p>1、第一个叫做 展开运算符(spread operator)，作用是和字面意思一样，就是把东西展开。可以用在array和object上都行。</p>
<p>2、第二个，第三个叫做 剩余操作符(rest operator)，是解构的一种，意思就是把剩余的东西放到一个array里面赋值给它。一般只针对array的解构<br>求数组中的最大值、最小值</p>
<pre><code>Math.max(...arr);//Math.min(...arr);
Math.max.apply(null, arr);
Math.max.call(Math, arr[0], arr[1], arr[2], arr[3]);
Math.max(arr[0], arr[1], arr[2], arr[3])
</code></pre>
<p>Math.max()方法，支持传递多个参数，比如：Math.max(1,4,5,2,9)</p>
<p>但是它不支持直接传递一个数组作为参数，比如：Math.max(new Array(1,4,5,2,9))。<br>Function.apply()是JS的一个OOP特性，一般用来模拟继承和扩展this的用途，对于上面这段代码，可以这样去理解：</p>
<p>XXX.apply是一个调用函数的方法，其参数为：apply(Function, Args)，</p>
<p>Math.max.call可以调用任意个参数；<br>Function为要调用的方法，Args是参数列表，当Function为null时，默认为上文，即</p>
<pre><code>Math.max.apply(null, arr) 
</code></pre>
<p>可认为是 apply(Math.max, arr)<br>然后，arr是一个参数列表，对于max方法，其参数是若干个数，即</p>
<pre><code>Math.max(a, b, c, d, ...)
</code></pre>
<p>当使用apply时，把所有参数加入到一个数组中，即<br>arr = [a, b, c, d, …]，代入到原式，</p>
<pre><code>Math.max.apply(null, [a, b, c, d, ...])
</code></pre>
<p>实际上等同于    </p>
<pre><code>Math.max(a, b, c, d, ...)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weiling Wu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weiling Wu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
