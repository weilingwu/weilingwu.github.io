<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="font-end study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="font-end study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiling Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>font-end study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">font-end study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/KMP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%A6-Prime%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/KMP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%A6-Prime%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP&动态规划&贪心算法…&Prime算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:43:53 / Modified: 13:45:36" itemprop="dateCreated datePublished" datetime="2022-01-06T13:43:53+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>问题</strong></p>
<p>KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。</p>
<p><strong>代码实现</strong><br>    function KMPSearch(str1, str2, next){<br>        for(var i = 0, j = 0;i&lt;str1.length;i++){<br>            while(j&gt;0 &amp;&amp; str1[i] != str2[j]){<br>                j = next[j-1];<br>            }<br>            if(str1[i] == str2[j]){<br>                j++;<br>            }<br>            if(j == str2.length){<br>                return i-j+1;<br>            }<br>        }<br>        return -1;<br>    }<br>    function KMPNext(dest){<br>        var next = new Array(dest.length);<br>        for(var i = 0;i&lt;dest.length;i++){<br>            dest[i] = 0;<br>        }<br>        for(var i = 0, j = 0;i&lt;dest.length;i++){<br>            while(j&gt;0 &amp;&amp; dest[i]!=dest[j]){<br>                j = next[j-1];<br>            }<br>            if(dest[i] == dest[j]){<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>        return next;<br>    }</p>
<p>#动态规划#<br><strong>背包问题</strong></p>
<p>背包问题：假如目前有三种物品：吉他、音响、电脑，他们的价值分别是1000、2000、2500，重量分别是1磅、3磅、2磅，背包的容量是固定值4磅，现在要把几种物品放进背包中使得在不超重的前提下背包的价值达到最大。<br>**代码实现    **<br>    function dynamic_planning(){<br>        var val = [1000, 3000, 2500];<br>        var w = [1, 3, 2];<br>        var sum = 4;<br>        var v = new Array(w.length);<br>        for(var i = 0;i&lt;v.length;i++){<br>            v[i] = new Array(sum);<br>        }<br>        for(i = 0;i&lt;v.length;i++){<br>            for(var j = 0;j&lt;sum;j++){<br>                v[i][j] = 0;<br>            }<br>        }<br>        for(i = 0;i&lt;v.length;i++){<br>            for(j = 0;j&lt;sum;j++){<br>                if(w[i-1]&gt;j){<br>                    v[i][j] = v[i-1][j];<br>                }<br>                else{<br>                    v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);<br>                }<br>            }<br>        }<br>            }</p>
<h1 id="贪心算法（最佳应用：集合覆盖问题）"><a href="#贪心算法（最佳应用：集合覆盖问题）" class="headerlink" title="贪心算法（最佳应用：集合覆盖问题）"></a>贪心算法（最佳应用：集合覆盖问题）</h1><p><strong>概念：</strong>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。</p>
<p>*算法思路：</p>
<p>1）遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没关系）</p>
<p>2）将这个电台加入到一个集合中（比如ArrayList），想办法把电台覆盖的地区在下次比较时去掉。</p>
<p>3）重复第一步，直到覆盖了全部的地区。<br>Prim算法（应用场景：修路问题）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/Tree-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/Tree-Graph/" class="post-title-link" itemprop="url">Tree&Graph</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:14:38 / Modified: 13:48:41" itemprop="dateCreated datePublished" datetime="2022-01-06T13:14:38+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的概念："><a href="#树的概念：" class="headerlink" title="树的概念："></a>树的概念：</h2><p>树是一种数据结构，它是由n(n≥1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h2 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h2><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。<br>树的特点：</p>
<p>由二叉树定义以及图示分析得出二叉树有以下特点：<br>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<br>性质：</p>
<p>1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）<br>2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）<br>3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p>
<p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br>(2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；<br>(3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>前序遍历，中序遍历，后序遍历。</p>
<p>前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。中序后序以此类推。</p>
<p><strong>//前序遍历</strong><br>    <script type="text/javascript"><br>            function TreeNode(val) {<br>              this.val = val;<br>              this.left = this.right = null;<br>             }</p>
<pre><code>        function preorderTraversal(root)&#123;
            const res = [];
            function inorder(root) &#123;
                if(root==null)
                    return;
                res.push(root.val);
                inorder(root.left);//递归
                inorder(root.right);
            &#125;
            inorder(root);

        &#125;
&lt;/script&gt;
</code></pre>
<p><strong>//中序遍历</strong><br>    function inorderTraversal(root){<br>        const res = [];<br>        function inorder(root) {<br>            if(root==null)<br>                return;<br>            inorder(root.left);//递归<br>            res.push(root.val);<br>            inorder(root.right);<br>        }</p>
<p><strong>//后序遍历</strong><br>    function postorderTraversal(root){<br>        const res = [];<br>        function inorder(root) {<br>            if(root==null)<br>                return;<br>            inorder(root.left);//递归<br>            inorder(root.right);<br>            res.push(root.val);<br>        }</p>
<h2 id="二叉树结点删除"><a href="#二叉树结点删除" class="headerlink" title="二叉树结点删除"></a>二叉树结点删除</h2><p>规定：</p>
<p>1）如果删除的节点是叶子节点，则删除该节点</p>
<p>2）如果删除的节点是非叶子节点，则删除该子树</p>
<p>思路：</p>
<p>1）考虑树是空树root。那么只有一个root节点，则等价将二叉树置空。</p>
<p>2）因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否删除节点，而不能去判断当前节点是不是需要删除节点。</p>
<p>3）如果当前节点的左子节点不为空，并且左子节点就是需要删除节点，就将this.left = null，并且就返回（结束递归删除）</p>
<p>4）如果当前节点的右子节点不为空，并且右子节点就是需要删除节点，就将this.right= null，并且就返回（结束递归删除）</p>
<p>5）如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除</p>
<p>6）如果第4步没有删除节点，则应当向右子树进行递归删除。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>(引自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42126431/article/details/89537923">https://blog.csdn.net/weixin_42126431/article/details/89537923</a>)<br>图的相关术语</p>
<p>1.1.有一条边相连的顶点叫相邻顶点；<br>1.2.一个顶点的度就是该顶点的相邻顶点数；<br>1.3.路径指顶点组成的连续序列；<br>1.4.简单路径没有重复顶点；<br>1.5.有向图和无向图<br>图的表示<br>邻接矩阵</p>
<p>array[i][j] ===1代表i节点和j节点相邻，否则不相邻<br>邻接表</p>
<p>相当于把每个节点的相邻节点一一列举出来。<br>关联矩阵</p>
<p>形式和邻接矩阵一样，只是把邻接矩阵的直接维度换成对应的边，适用于边比顶点多的情况。<br>创建图类</p>
<p>接下来就采用邻接表的方式创建上面的图并且采用字典来表示：</p>
<p>创建字典类    </p>
<p> //创建字典类<br>    function Dictionary(){<br>        var items = {};</p>
<pre><code>    //set(key,value)向字典里添加新元素，这里主要用来添加边
    this.set = function(key,value)&#123;
        items[key] = value;
    &#125;

    //has(key)如果存在就返回true，否则false
    this.has = function(key)&#123;
        return key in items;
    &#125;

    //get(key)通过key查找特定的数值并返回，这里主要用来查找顶点对应的边数组
    this.get = function(key)&#123;
        return this.has(key) ? items[key] : undefined;
    &#125;
&#125;
</code></pre>
<p>创建图类    </p>
<p>//创建图类Graph()<br>    function Graph(){<br>        var vertices = [];    //用来储存顶点<br>        var adjList = new Dictionary();    //用来储存边</p>
<pre><code>    //创建initializeColor用来初始化各个顶点的颜色，为遍历过程中的标记做准备
    var initializeColor = function()&#123;
        var color = [];
        for (var i=0; i&lt;vertices.length; i++)&#123;
            color[vertices[i]] = &#39;white&#39;;
        &#125;
        return color;
    &#125;
    
    //addVertex(key)用来添加顶点
    this.addVertex = function(v)&#123;
        vertices.push(v);
        adjList.set(v, []);
    &#125;

    //addEdge(key,value)用来添加边v-w
    this.addEdge = function(v,w)&#123;
        adjList.get(v).push(w);
        adjList.get(w).push(v);
    &#125;

    //toString()把邻接表转化成字符串的形式，便于输出显示
    this.toString = function()&#123;
        var s = &#39;&#39;;
        for(var i=0; i&lt;vertices.length; i++)&#123;
            s += vertices[i] + &#39;-&gt;&#39;;
            var neighbors = adjList.get(vertices[i]);
            for(var j=0; j&lt;neighbors.length; j++)&#123;
                s += neighbors[j] + &#39; &#39;;
            &#125;
            s += &#39;\n&#39;;
        &#125;
        return s;
    &#125;
&#125;
</code></pre>
<p>创建实例<br>//创建实例<br>    var graph = new Graph();<br>    var myVertices = [‘A’,’B’,’C’,’D’,’E’,’F’,’G’,’H’,’I’];<br>    //添加顶点<br>    for(var i=0; i&lt;myVertices.length; i++){<br>        graph.addVertex(myVertices[i]);<br>    }<br>//逐一加入边<br>    graph.addEdge(‘A’,’B’);<br>    graph.addEdge(‘A’,’C’);<br>    graph.addEdge(‘A’,’D’);<br>    graph.addEdge(‘C’,’G’);<br>    graph.addEdge(‘C’,’D’);<br>    graph.addEdge(‘D’,’G’);<br>    graph.addEdge(‘D’,’H’);<br>    graph.addEdge(‘B’,’E’);<br>    graph.addEdge(‘B’,’F’);<br>    graph.addEdge(‘E’,’I’);<br>    console.log(graph.toString());</p>
<p>输出的结果为：<br>A-&gt;B C D<br>B-&gt;A E F<br>C-&gt;A G D<br>D-&gt;A C G H<br>E-&gt;B I<br>F-&gt;B<br>G-&gt;C D<br>H-&gt;D<br>I-&gt;E </p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>采用队列的方式，先添加节点的先被探索；<br>采用三种颜色来反应节点的状态：<br>白色：还没被访问；<br>灰色：被访问但未被探索；<br>黑色：被访问且探索过；<br>思路：</p>
<p>首先搜索节点A，探索A节点的相邻节点B,C,D,把其加入队列中，再逐一出队列进行探索，从而实现广度遍历。<br>添加bfs方法     </p>
<p>//广度优先遍历，在Graph()类中添加以下方法<br>    this.bfs = function(v, callback){<br>        var color = initializeColor();    //初始化节点，都标记为白色<br>        var queue = [];    //创建队列用来顶点的入队；<br>        queue.push(v);    //访问的节点入队列<br>        while(!queue.length==0){    //如果队列非空就执行以下<br>            var u = queue.shift();    //节点出队列<br>            var neighbors = adjList.get(u);  //探索节点对应的边<br>            color[u] = ‘grey’;    //把搜索过的节点变成灰色<br>            for (var i=0; i&lt;neighbors.length; i++){<br>                var w = neighbors[i];<br>                if(color[w] === ‘white’){    //如果探索到的子节点是白色就逐一变灰并入队列<br>                    color[w] = ‘grey’;<br>                    queue.push(w);<br>                }<br>            }<br>            color[u] = ‘black’;        //节点完成搜索和探索的过程，直接变黑<br>            if(callback){<br>                callback(u);        //回调函数，可以用来输出<br>            }<br>        }<br>    }</p>
<p>创建bfs实例<br>//bfs实例<br>    function printNode(value){<br>        console.log(‘Visited vertex:’+value);<br>    }<br>    graph.bfs(myVertices[0],printNode);</p>
<p>bfs输出结果<br>Visited vertex:A<br>Visited vertex:B<br>Visited vertex:C<br>Visited vertex:D<br>Visited vertex:E<br>Visited vertex:F<br>Visited vertex:G<br>Visited vertex:H<br>Visited vertex:I</p>
<p>使用BFS寻找最短路径<br>    this.BFS = function(v){<br>            var color = initializeColor(),<br>            queue = [],<br>            d = [],    //用来储存从v到u的距离<br>            pred = [];    //用来储存节点的前溯点<br>            queue.push(v);</p>
<pre><code>        for(var i=0; i&lt;vertices.length; i++)&#123;
            d[vertices[i]] = 0;        //初始化
            pred[vertices[i]] = null;
        &#125;

        while(!queue.length == 0)&#123;
            var u = queue.shift();
            var neighbors = adjList.get(u);
            color[u] = &#39;grey&#39;;
            for (i=0; i&lt;neighbors.length; i++)&#123;
                var w = neighbors[i];
                if(color[w] === &#39;white&#39;)&#123;
                    color[w] = &#39;grey&#39;;
                    d[w] = d[u]+1;    //从头节点到w的距离
                    pred[w] = u;
                    queue.push(w);
                &#125;
            &#125; 
            color[u] = &#39;black&#39;;
        &#125;
        return&#123;
            distance:d,
            predecessers:pred
        &#125;
    &#125;
</code></pre>
<p>创建BFS实例<br>//BFS实例<br>    var shortestPathA = graph.BFS(myVertices[0]);//需要输入头节点myVertice[0]<br>    //console.log(shortestPathA);</p>
<p>//搜索路径BFS<br>    var fromVertex = myVertices[0];<br>    for (var i=1; i&lt;myVertices.length; i++){<br>        var toVertex = myVertices[i];<br>        var path = [];    //path用来储存路径<br>        for (var v=toVertex; v!==fromVertex; v=shortestPathA.predecessers[v]){<br>            path.push(v);<br>        }<br>        path.push(fromVertex);<br>        var s = path.pop();<br>        while(!path.length==0){<br>            s += ‘-‘ + path.pop();<br>        }<br>        console.log(s)<br>    }</p>
<p>BFS输出结果<br>A-B<br>A-C<br>A-D<br>A-B-E<br>A-B-F<br>A-C-G<br>A-D-H<br>A-B-E-I</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>采用栈的方式，先添加节点的先被探索；<br>由递归实现。<br>思路：</p>
<p>从节点A开始，探索到A的相邻节点B,C,D压入栈中（这里的代码采用for循环，所以没有实质上的栈，但是用栈更容易理解），接着搜索B，探索到B的相邻节点E,F压入栈中，以此递归。<br>添加dfs方法<br>    this.dfs = function(callback){<br>            var color = initializeColor();<br>            for (var i=0; i&lt;vertices.length; i++){<br>                if(color[vertices[i]]===’white’){<br>                    dfsVisit(vertices[i], color, callback)//调用递归函数<br>                }<br>            }<br>        }</p>
<pre><code>    var dfsVisit = function(u, color, callback)&#123;
        color[u] = &#39;grey&#39;;
        if(callback)&#123;
            callback(u);
        &#125;
        var neighbors = adjList.get(u);
        for(var i=0; i&lt;neighbors.length; i++)&#123;
            var w = neighbors[i];
            if(color[w] === &#39;white&#39;)&#123;
                dfsVisit(w, color, callback);
            &#125;
        &#125;
        color[u] = &#39;black&#39;;
    &#125;
</code></pre>
<p>创建dfs实例</p>
<p>graph.dfs(printNode);</p>
<p>dfs输出结果<br>Visited vertex:A<br>Visited vertex:B<br>Visited vertex:E<br>Visited vertex:I<br>Visited vertex:F<br>Visited vertex:C<br>Visited vertex:G<br>Visited vertex:D<br>Visited vertex:H</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/sort/" class="post-title-link" itemprop="url">sort</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:07:46 / Modified: 13:14:09" itemprop="dateCreated datePublished" datetime="2022-01-06T13:07:46+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bubble-Sorting"><a href="#Bubble-Sorting" class="headerlink" title="Bubble Sorting"></a>Bubble Sorting</h1><p>冒泡排序：（Bubble Sorting）：通过对待排序序列从前向后（从下标较小的元素开始）通过依次比较相邻的元素的值，若发现逆序则交换，使值较大的元素逐渐从前向后移动，就像水底的气泡一样逐渐网上冒。<br>    function bubbleSort(arr) {<br>        var i = arr.length, j;<br>        var tempExchangVal;<br>        while (i &gt; 0) {<br>            for (j = 0; j &lt; i - 1; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    tempExchangVal = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = tempExchangVal;<br>                }<br>            }<br>            i–;<br>        }<br>        return arr;<br>    }</p>
<p>var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];<br>var arrSorted = bubbleSort(arr);<br>console.log(arrSorted);<br>alert(arrSorted);</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><strong>算法描述：</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<p>初始状态：无序区为R[1…n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。<br>    function selectionSort(arr) {<br>        var len = arr.length;<br>        var minIndex, temp;<br>        for (var i = 0; i &lt; len - 1; i++) {<br>            minIndex = i;<br>            for (var j = i + 1; j &lt; len; j++) {<br>                if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数<br>                    minIndex = j;                 // 将最小数的索引保存<br>                }<br>            }<br>            temp = arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        }<br>        return arr;<br>    } </p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>代码中定义了两个指针：currentIndex，preIndex。<br>    var currentIndex, preIndex, value;<br>    for(var i = 1;i&lt;arr.length;i++)<br>    {<br>        currentIndex = i;<br>        preIndex = i-1;<br>        value = arr[currentIndex];<br>        while(value&lt;arr[preIndex] &amp;&amp; preIndex&gt;=0)<br>        {<br>            arr[currentIndex] = arr[preIndex];<br>            currentIndex = preIndex;<br>            preIndex–;<br>        }<br>        arr[preIndex+1] = value;<br>    }<br>    return arr;<br>    }<br>    var arr = [-1, 2, 5, 9, 1, 5, 7, 6, 8];<br>    var arrSorted = InsertSort(arr);<br>    console.log(arrSorted);<br>    alert(arrSorted);</p>
<h1 id="希尔排序（shell-sorting）"><a href="#希尔排序（shell-sorting）" class="headerlink" title="希尔排序（shell sorting）"></a>希尔排序（shell sorting）</h1><p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p><strong>算法描述：</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br> function ShellSort(arr) {<pre><code>         var k = 0;
         for(var gap = Math.floor(arr.length/2 ); gap&gt;=1; Math.floor(gap /= 2))
         &#123;
             k =0;
             while(k&lt;arr.length-gap)
             &#123;
                 if(arr[k]&gt;arr[k+gap])
                 &#123;
                     t = arr[k];
                     arr[k] = arr[k+gap];
                     arr[k+gap] = t;
                 &#125;
                 k++;
             &#125;
         &#125;
         return arr;
     &#125;
</code></pre>
</li>
</ol>
<h1 id="归并排序（merge-sorting）"><a href="#归并排序（merge-sorting）" class="headerlink" title="归并排序（merge sorting）"></a>归并排序（merge sorting）</h1><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br><strong>算法描述：</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。<br> function MergeSorting(arr) {<pre><code> if(arr.length&lt;2)
     return arr;
 var middle = Math.floor(arr.length/2);
 var left = arr.slice(0, middle);
 var right = arr.slice(middle, arr.length);
 return Merge(MergeSorting(left), MergeSorting(right));
     &#125;
</code></pre>
 function Merge(left, right){<pre><code> var result = [];
 while(left.length&gt;0&amp;&amp;right.length&gt;0)&#123;
     if(left[0]&gt;right[0])
     &#123;
         result.push(right.shift());
     &#125;
     else&#123;
         result.push((left.shift()))
     &#125;&#125;
 while(left.length)&#123;
     result.push(left.shift());
 &#125;
 while(right.length)&#123;
     result.push(right.shift());
 &#125;


 return result;
</code></pre>
 }</li>
</ol>
<h1 id="快速排序（quick-sorting）"><a href="#快速排序（quick-sorting）" class="headerlink" title="快速排序（quick sorting）"></a>快速排序（quick sorting）</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br><strong>算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <title>bottom</title>
     <script type="text/javascript">
         function quicksort(arr, left, right){
             var l = left;
             var r = right;
             var pivot = arr[Math.floor((left+right)/2)];
             while (l<r){
                 while(arr[l]<pivot){
                     l++;
                 }
                 while(arr[r]>pivot){
                     r--;
                 }
                 if(l>=r){
                     break;
                 }
                 var temp = arr[l];
                 arr[l] = arr[r];
                 arr[r] = temp;
                 if(arr[l] == pivot){
                     r--;
                 }
                 if(arr[r]==pivot){
                     l++;
                 }
             }
             if(l==r){//防止栈溢出
                 l++;
                 r--;
             }
             if(left<r){//向左递归
                 quicksort(arr, left, r);
             }
             if(right>l){//向右递归
                 quicksort(arr, l, right);
             }
 
<pre><code>     &#125;
     var arr = [1,2,-1,5,7,3,0];
     quicksort(arr, 0, arr.length-1);
     alert(arr);
 &lt;/script&gt;
</code></pre>
 </head>
 <body>
     我是bottom；
 </body>
 </html></li>
</ol>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。<br><strong>算法描述</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<br> function BucketSorting(arr){<pre><code> var maxvalue = arr[0];
 for(var i = 1; i&lt;arr.length;i++)&#123;
     if(maxvalue&lt;arr[i])&#123;
         maxvalue = arr[i];
     &#125;
 &#125;
 var maxlen = (maxvalue + &quot;&quot;).length;
 for(var i = 0,n = 1;i&lt;maxlen;i++,n*=10)&#123;
     var takenvalue;
     var returnResult = new Array();
     for (var k = 0; k&lt;10;k++)&#123;
         returnResult[i]=[];
     &#125;
     var arrlen = new Array(10);
     for(var j = 0;j&lt;arr.length;j++)&#123;
         takenvalue = Math.floor(arr[j]/n%10);
         alert(typeof arr[j]);
         returnResult[takenvalue].push(arr[j]);
         arrlen[takenvalue] += 1;
     &#125;
     var index = 0;
     for(var k = 0;k&lt;10;k++)&#123;
         if(arrlen[k]&gt;0)&#123;
             for(var m = 0;m&lt;arrlen[k];m++)
                 arr[index++] = returnResult[k][m];
         &#125;
     &#125;
 &#125;
 return arr;
     &#125;
</code></pre>
</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。升序，大顶堆；降序，小顶堆。<br>算法描述</p>
<pre><code>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) &#123;   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;
 
function heapify(arr, i) &#123;     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;
 
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;
 
    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;
 
function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
 
function heapSort(arr) &#123;
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;
</code></pre>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/jQuery-bootstrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/jQuery-bootstrap/" class="post-title-link" itemprop="url">jQuery&bootstrap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:03:18 / Modified: 13:07:18" itemprop="dateCreated datePublished" datetime="2022-01-06T13:03:18+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h1><pre><code>jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。

基础语法： $(*selector*).*action*()

    美元符号定义 jQuery
    选择符（selector）“查询&quot;和&quot;查找” HTML 元素
    jQuery 的 action() 执行对元素的操作

实例:

    $(this).hide() - 隐藏当前元素
    $(“p”).hide() - 隐藏所有

    元素
    $(“p.test”).hide() - 隐藏所有 class=“test” 的

    元素
    $(“#test”).hide() - 隐藏 id=“test” 的元素

文档就绪事件

您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：
$(document).ready(function()&#123;
 // 开始写 jQuery 代码...  
        &#125;);

这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。

如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：

    试图隐藏一个不存在的元素
    获得未完全加载的图像的大小

**提示：**简洁写法（与以上写法效果相同）:    

$(function()&#123;
    // 开始写 jQuery 代码...  
        &#125;);

以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。
</code></pre>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><pre><code>jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。

jQuery 选择器基于元素的 id、类、类型、属性、属性值等&quot;查找&quot;（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。

jQuery 中所有选择器都以美元符号开头：$()。

元素选择器

jQuery 元素选择器基于元素名选取元素。

在页面中选取所有

元素:    

$(&quot;p&quot;)
</code></pre>
<h2 id="id-选择器"><a href="#id-选择器" class="headerlink" title="#id 选择器"></a>#id 选择器</h2><pre><code>jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。

页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。

通过 id 选取元素语法如下：


$(&quot;#test&quot;)

.class 选择器

jQuery 类选择器可以通过指定的 class 查找元素。

语法如下：


$(&quot;.test&quot;)
</code></pre>
<h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><pre><code>页面对不同访问者的响应叫做事件。

事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。

实例：

    在元素上移动鼠标。
    选取单选按钮
    点击元素
</code></pre>
<h2 id="click"><a href="#click" class="headerlink" title="click()"></a>click()</h2><p>click() 方法是当按钮点击事件被触发时会调用一个函数。</p>
<p>该函数在用户点击 HTML 元素时执行。</p>
<p>在下面的实例中，当点击事件在某个</p>
<p>元素上触发时，隐藏当前的</p>
<p>元素：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
    &lt;/script&gt;
    &lt;script&gt;
        $(function()&#123;
            $(&quot;p&quot;).click(function()&#123;
                $(this).hide();
                        &#125;)&#125;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt;
    &lt;p&gt;继续点我!&lt;/p&gt;
    &lt;p&gt;接着点我!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>dblclick() – 鼠标双击事件， mouseenter() – 当鼠标指针穿过元素， mouseleave() – 当鼠标指针离开元素</p>
<p>，mousedown() – 当鼠标指针移动到元素上方，并按下鼠标按键，等等。</p>
<p>jQuery Fading 方法：</p>
<p>通过 jQuery，您可以实现元素的淡入淡出效果。</p>
<p>jQuery 拥有下面四种 fade 方法：</p>
<pre><code>    fadeIn()
    fadeOut()
    fadeToggle()
    fadeTo()
</code></pre>
<h2 id="jQuery动画–animate-方法"><a href="#jQuery动画–animate-方法" class="headerlink" title="jQuery动画–animate() 方法"></a>jQuery动画–animate() 方法</h2><p>jQuery animate() 方法用于创建自定义动画。</p>
<p>语法：</p>
<p>$(selector).animate({params},speed,callback);</p>
<p>必需的 params 参数定义形成动画的 CSS 属性。</p>
<p>可选的 speed 参数规定效果的时长。它可以取以下值：“slow”、“fast” 或毫秒。</p>
<p>可选的 callback 参数是动画完成后所执行的函数名称。<br>    <!DOCTYPE html><br>    <html><br>    <head><br>        <meta charset="utf-8"><br>        <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"><br>        </script><br>        <script><br>            $(document).ready(function(){<br>                $("button").click(function(){<br>                    $("div").animate({left:'250px'});<br>                });<br>            });<br>        </script><br>    </head></p>
<pre><code>&lt;body&gt;
&lt;button&gt;开始动画&lt;/button&gt;
&lt;p&gt;默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。
    如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!&lt;/p&gt;
&lt;div style=&quot;background:#98bf21;height:100px;width:100px;position:absolute;&quot;&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="我的第一个用了-boostrap-https-v3-bootcss-com-的代码："><a href="#我的第一个用了-boostrap-https-v3-bootcss-com-的代码：" class="headerlink" title="我的第一个用了[boostrap][https://v3.bootcss.com]的代码："></a>我的第一个用了[boostrap][<a href="https://v3.bootcss.com]的代码：">https://v3.bootcss.com]的代码：</a></h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;Bootstrap 实例 - 响应式的列重置&lt;/title&gt;
   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

   &lt;div class = &quot;container&quot;&gt;&lt;!--      .container 类用于固定宽度并支持响应式布局的容器--&gt;
      123
   &lt;/div&gt;
   &lt;div class=&quot;container-fluid&quot;&gt; &lt;!--      .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。--&gt;
      456
   &lt;/div&gt;
   &lt;table class=&quot;table table-bordered&quot;&gt;&lt;!--      添加 .table-bordered 类为表格和其中的每个单元格增加边框。--&gt;
      &lt;tr&gt;
         &lt;td&gt;姓名&lt;/td&gt;
         &lt;td&gt;科目&lt;/td&gt;
         &lt;td&gt;成绩&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;夏明&lt;/td&gt;
         &lt;td&gt;数学&lt;/td&gt;
         &lt;td&gt;149&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;徐雪&lt;/td&gt;
         &lt;td&gt;英语&lt;/td&gt;
         &lt;td&gt;139&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>要使用boostrap，下面这些代码是必须要添加上的：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
  &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
  &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;
&lt;/div&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/css/" class="post-title-link" itemprop="url">css</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 13:00:02 / Modified: 13:02:43" itemprop="dateCreated datePublished" datetime="2022-01-06T13:00:02+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>css的选择器学习：<br>    <style type = "text/css"><br>            /<em>标签选择器</em>/<br>            table{<br>                height: 300px;<br>                width: 200px;<br>                border: solid 1px;<br>                background-color: red;<br>            }<br>            /<em>id选择器</em>/<br>            #t1{<br>                background-color: blue;<br>            }<br>            /<em>类选择器</em>/<br>            .common{<br>                color:red;<br>            }<br>            /<em>组合选择器</em>/<br>            table,.common{<br>                color:red;<br>            }<br>        </style></p>
<p>标签选择器：标签名{样式名1：样式值1；…}</p>
<p>作用：会将当前网页内所有该标签增加相同的样式</p>
<p>id选择器：#标签的id属性值{样式名1：样式值1；…}</p>
<p>作用：给某个指定的标签添加样式</p>
<p>类选择器：.类选择器名{样式名1：样式值1；…}</p>
<p>作用：给不同的标签添加相同的样式</p>
<p>全部选择选择器：*{样式名1：样式值1；…}</p>
<p>作用：选择所有的HTML标签，并添加相同的样式</p>
<p>组合选择器：选择器1，选择器2，…{样式名1：样式值1；…}</p>
<p>作用：解决不同的选择器之间重复样式的问题<br>css样式    </p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>照片墙</title>
    <style type = "text/css">
        body{
            text-align: center;
            background-color: gray;
        }
        img{
            width: 20%;/*设置高度*/
            padding: 10px;/*设置内边距*/
            background-color: white;/*设置背景颜色*/
            transform: rotate(-10deg);/*设置倾斜角度*/
            margin-left: 10px;/*设置外边距*/
        }
        img:hover{
            transform: rotate(0deg) scale(1.5);/*设置倾斜角度和缩放比例*/
            z-index: 2;/*    设置显示优先级别*/
        }
    </style>
</head>
<body>
    <br/><br/><br/><br/><br/><br/>
    <img src="https://img0.baidu.com/it/u=652732258,3535184171&fm=26&fmt=auto" alt=""/>
    <img src="https://img0.baidu.com/it/u=3459544028,1422320751&fm=26&fmt=auto" alt=""/>
    <img src="https://img1.baidu.com/it/u=3806063294,3480903396&fm=26&fmt=auto" alt=""/>
    <img src="https://img0.baidu.com/it/u=121804161,3053314887&fm=26&fmt=auto" alt=""/>
    <br/><br/>
    <img src="https://img2.baidu.com/it/u=3108583535,4104247024&fm=253&fmt=auto&app=120&f=JPEG?w=640&h=360" alt=""/>
    <img src="https://img0.baidu.com/it/u=2135482323,1459336928&fm=26&fmt=auto" alt=""/>
    <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw500h280%2F20171219%2F13f2-fypvuqe0957796.gif&refer=http%3A%2F%2Fn.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1636370856&t=e55fc69178ee867433ab3e74c60adbf2" alt=""/>
    <img src="https://img2.baidu.com/it/u=2414916686,3188715239&fm=26&fmt=auto" alt=""/>
    <hr/>
</body>
</html>

<p>盒子模型</p>
<p>外边距：margin</p>
<p>作用：用来设置元素与元素之间的间隔</p>
<p>居中设置：margin：0px auto；上下间隔是0px，水平居中。</p>
<p>边框：border</p>
<p>作用：用来设置元素的边框大小，可以单独设置上下左右</p>
<p>内边距：padding</p>
<p>作用：设置内容与边框之间的距离，内边距不会改变内容区域的大小，可以单独设置上下左右的内边距</p>
<p>内容区域：改变内容区域的大小，设置宽和高即可改变内容区域的大小。<br>    <!DOCTYPE html><br>    <html lang="en"><br>    <head><br>        <meta charset="UTF-8"><br>        <title>盒子模型</title><br>        <style type = "text/css"><br>            div{<br>                width: 300px;<br>                height: 300px;<br>            }<br>            #div01{<br>                border: solid 1px orange;<br>            }<br>            #div02{<br>                border:solid 1px blueviolet;<br>            }<br>            #div03{<br>                border:solid 1px aqua;<br>            }<br>            #div04{<br>                border:bisque;<br>            }<br>        </style><br>    </head><br>    <body></p>
<pre><code>    &lt;div id = &quot;div01&quot;&gt;
        我是div01
    &lt;/div&gt;
    &lt;div id = &quot;div02&quot;&gt;
        我是div02
    &lt;/div&gt;
    &lt;div id = &quot;div03&quot;&gt;
        我是div03
    &lt;/div&gt;
    &lt;div id = &quot;div04&quot;&gt;
        我是div04
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>CSS模块<br>边框</p>
<p>边框属性：</p>
<p>border-radius 用于创建圆角<br>box-shadow 用来添加阴影<br>border-image 属性允许你指定一个图片作为边框，用于创建上文边框的原始图像</p>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
    &lt;style&gt;
        #test&#123;
            width:300px;
            height: 100px;
            padding: 1px;
            border: 2px solid #00a0ff;
            border-radius: 25px;
            background-image: url(&quot;https://img0.baidu.com/it/u=280905735,1446098188&amp;fm=26&amp;fmt=auto&quot;);
            box-shadow: 10px 10px 10px aqua;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id = &quot;test&quot;&gt;
    这是一道美丽的风景线
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>css背景</p>
<p>background-image 添加背景图片，不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<p>background-sizebackground-size 指定背景图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。</p>
<p>CSS3中可以指定背景图片，让我们重新在不同的环境中指定背景图片的大小。您可以指定像素或百分比大小。你指定的大小是相对于父元素的宽度和高度的百分比的大小。</p>
<p>background-origin</p>
<p>background-clip</p>
<p>这部分内容很有意思，要自己去试试，我就不介绍全部的细节了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/html/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/html/" class="post-title-link" itemprop="url">html</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 12:55:25 / Modified: 13:56:21" itemprop="dateCreated datePublished" datetime="2022-01-06T12:55:25+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTML基础学习"><a href="#HTML基础学习" class="headerlink" title="HTML基础学习"></a>HTML基础学习</h1><h2 id="body-标签"><a href="#body-标签" class="headerlink" title="body 标签"></a>body 标签</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 aligh = &quot;left&quot;&gt;
    全红禅祝大家国庆节快乐！
&lt;/h1&gt;

&lt;hr width = &quot;20%&quot; size = 5px color = &quot;purple&quot;/&gt;
&lt;p&gt;
    全红婵发文祝大家国庆节快乐，并且晒出长隆假期游玩照，准备恢复挥汗如雨的训练生活了，妹妹玩得开心啊! 妹妹真的太可爱了!
&lt;/p&gt;
    哈哈哈，&lt;b&gt;全红婵&lt;/b&gt;妹妹有心啦！特意发文祝大家国庆节快乐！还真是个体贴又温暖的&lt;i&gt;女孩呢！&lt;/i&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你也要快乐过节，&lt;u&gt;快乐训练！&lt;/u&gt;期待你下次精彩表现。
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>标题标签</strong>： h1到h6：将其中的内容加粗加黑显示，并且显示依次减弱，自带换行功能（块级标签）。</p>
<p><strong>属性</strong>：aligh = “center”/ “left”/“right”</p>
<p><strong>水平线标签</strong>：hr 在页面中显示一条水平线，默认居中显示</p>
<p><strong>属性</strong>：</p>
<ul>
<li><p>width = “宽度” 设置水平线的宽度</p>
</li>
<li><p>size = “高度” 设置水平线的高度</p>
</li>
<li><p>color = “颜色” 设置水平线的颜色</p>
</li>
</ul>
<p><strong>段落标签</strong>：p 会将一段数据作为整体进行显示自动换行，段间距比较大</p>
<p><strong>换行符</strong>：br 告诉浏览器在此位置增加空格</p>
<p><strong>权重标签</strong>： </p>
<ul>
<li><p>b 会将内容加黑显示</p>
</li>
<li><p>i 会将内容斜体显示</p>
</li>
<li><p>u 会将内容增加下划线</p>
</li>
<li><p>del 增加中划线</p>
<h2 id="表单学习"><a href="#表单学习" class="headerlink" title="表单学习"></a>表单学习</h2>  <table border="1px" cellspacing="0px" cellpadding="8px">
      <tr height = "27px">
          <td colspan="5">基本情况</td>
      </tr>
      <tr height = "27px">
          <td width = "120px">姓名</td>
          <td width = "120px"></td>
          <td width = "120px">性别</td>
          <td width = "120px"></td>
          <td width = "120px" rowspan="7"></td>
      </tr>
      <tr height = "27px">
          <td>民族</td>
          <td></td>
          <td>出生年月</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>政治面貌</td>
          <td></td>
          <td>健康</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>籍贯</td>
          <td></td>
          <td>学历</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>电子信箱</td>
          <td></td>
          <td>联系电话</td>
          <td></td>
      </tr>
      <tr height = "27px">
          <td>专业</td>
          <td colspan="3"></td>
      </tr>
      <tr height = "27px">
          <td>毕业院校</td>
          <td colspan="3"></td>
      </tr>
      <tr height = "27px">
          <td>求职意向</td>
          <td colspan="4"></td>
      </tr>
  </table></li>
</ul>
<ul>
<li><p>table：声明一个表格</p>
</li>
<li><p>tr：声明一行，设置行高以及该行所有单元格的高度</p>
</li>
<li><p>th：声明一个单元格，表头格，默认居中加黑显示</p>
</li>
<li><p>td：声明一个单元格，默认居左显示原始数据</p>
</li>
<li></li>
</ul>
<p><strong>注意</strong>：行高即该行所有单元格的宽度，单元格的宽度即列宽</p>
<p><strong>简单写法</strong>：五行六列的表格</p>
<pre><code>table&gt;tr*5&gt;td*6
</code></pre>
<p><strong>属性</strong>：</p>
<ul>
<li><p>border：给表格添加边框</p>
</li>
<li><p>width：设置表格的宽度</p>
</li>
<li><p>height：设置表格的高度</p>
</li>
<li><p>cellpadding：设置内容居边框的距离</p>
</li>
<li><p>cellspacing：设置边框的大小</p>
</li>
</ul>
<p><strong>单元格合并</strong>：</p>
<ol>
<li>首先确保表格是一个规整的表格</li>
<li>根据要合并的单元格，找到其所在的源码位置</li>
<li>行合并：在要合并的单元格中第一个单元格上使用属性rowspan=“要合并的单元格的个数”，并删除其他单元格完成合并</li>
</ol>
<p>列合并：在要合并的单元格中任意一个上使用属性colspan = “要合并的单元格的个数”并删除其他要合并的单元格完成合并</p>
<h2 id="内嵌标签学习"><a href="#内嵌标签学习" class="headerlink" title="内嵌标签学习"></a>内嵌标签学习</h2><p><strong>内嵌标签</strong>：iframe</p>
<ul>
<li><p>src：要显示的网页资源路径，可以是本地（相对路径）也可以是网络资源（URL），默认当前页面打开及加载src指向的资源</p>
</li>
<li><p>width：设置区域的宽度</p>
</li>
<li><p>height：设置区域的高度</p>
</li>
<li><p>form表单标签</p>
</li>
</ul>
<p>作用：收集并提交用户数据给指定服务器。</p>
<p>注意：form标签会收集其标签内部的数据，要提交的表单项必须拥有name属性，否则不会提交</p>
<h2 id="属性："><a href="#属性：" class="headerlink" title="属性："></a><strong>属性</strong>：</h2><ul>
<li><p>action：收集的数据的提交地址，URL</p>
</li>
<li><p>method：收集的数据的提交方式，</p>
</li>
<li><p>get：适合小量数据，表单数据以？隔开拼接在用户书写的URL后面，不同的键值对用&amp;连接，不安全。</p>
</li>
<li><p>post：适合大量数据，安全，隐式提交。</p>
</li>
<li><p>表单域标签：作用：给用户提供可以进行数据书写或者选择的标签，</p>
</li>
<li><p>文本框：input：</p>
</li>
</ul>
<p><strong>type</strong>：</p>
<ul>
<li><p>text 收集少量文本数据，用户可见</p>
</li>
<li><p>password 收集用户密码数据</p>
</li>
<li><p>name：数据提交的键，也会被js使用</p>
</li>
<li><p>value：默认值</p>
</li>
</ul>
<p><strong>单选框</strong>：type = “radio”，name属性相同的只能选一项数据 value 要提交的数据，checked checked使用此属性的单选默认是选择状态</p>
<p><strong>form表单标签</strong>：form标签会将其内部所有的form表单标签中的所有的用户数据按照method指定的提交方式提交给action指明的地址</p>
<pre><code>&lt;form action = &#39;#&#39; method=&quot;get&quot;&gt;
    用户名&lt;input type=&quot;text&quot; name = &quot;rtr&quot;/&gt;&lt;br/&gt;
    密码&lt;input type = &quot;text&quot; name = &quot;uid&quot;/&gt;&lt;br&gt;
    &lt;input type = &quot;submit&quot; value=&quot;提交&quot;/&gt;
    性别：男&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;male&quot; checked = &quot;checked&quot;/&gt;女&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;female&quot;/&gt;
&lt;/form&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/JS-Study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/JS-Study/" class="post-title-link" itemprop="url">JS Study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 12:44:56 / Modified: 13:58:29" itemprop="dateCreated datePublished" datetime="2022-01-06T12:44:56+08:00">2022-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>输出语句</strong></p>
<p>JavaScript 没有任何打印或者输出的函数。JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li><p>使用 window.alert() 弹出警告框。</p>
</li>
<li><p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
</li>
<li><p>使用 innerHTML 写入到 HTML 元素。</p>
</li>
<li><p>使用 console.log() 写入到浏览器的控制台。</p>
</li>
</ul>
<p>一个需要注意的点：return 语句，少写了return语句返回值会是undefined，在你得到输出的结果是undefined时要想到是不是少了return。<br><strong>for循环的使用</strong><br>    <!DOCTYPE html><br>    <html><br>    <head><br>        <meta charset="utf-8"><br>        <title>study</title><br>        <script type = "text/javascript"><br>            for(var i = 10;i<15;i++)<br>            {<br>                document.write(i);<br>                document.write('<br />');<br>            }</p>
<pre><code>    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JS中的for循环与JAVA中的很相似，这里就不多说了。注意：JS中的换行符是<br>    <br /><br><strong>条件语句</strong><br>if(age &gt;= 18)<br>{<br>    console.log(age);<br>}</p>
<p><strong>对象的属性</strong><br>    var obj = new Object();<br>    obj.name = “孙悟空”;<br>    obj.var = 798;</p>
<p>对象的属性名不强制要求遵守标识符的规范，但是我们使用时还是尽量按照标识符的规范去做。如果要使用特殊的属性名，不能采用.的方式来操作，使用：对象[“属性名”] = 属性值。</p>
<h4 id="JS的普通函数"><a href="#JS的普通函数" class="headerlink" title="JS的普通函数"></a>JS的普通函数</h4><p><strong>声明方式一：</strong><br>    function fun()<br>    {<br>        var sum = 0;<br>        for(var i = 0; i&lt;100; i++)<br>        {<br>            sum += i;<br>        }<br>        return sum<br>    }<br>    alert(fun());</p>
<p><strong>声明方式二：</strong><br>    var fun = function(){<br>                var sum = 0;<br>                for(var i = 0; i&lt;100; i++)<br>                {<br>                    sum += i;<br>                }<br>                return sum<br>            }<br>            alert(fun());</p>
<p><strong>箭头函数</strong><br>ES6标准新增了一种新的函数：Arrow Function（箭头函数）<br>    x =&gt; x * x<br>相当于：<br>    function (x) {<br>        return x * x;<br>    }</p>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return：<br>    x =&gt; {<br>        if (x &gt; 0) {<br>            return x * x;<br>        }<br>        else {<br>            return - x * x;<br>        }<br>    }</p>
<p>如果参数不是一个，就需要用括号()括起来：<br>    // 两个参数:<br>    (x, y) =&gt; x * x + y * y</p>
<pre><code>// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; &#123;
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) &#123;
        sum += rest[i];
    &#125;
    return sum;
&#125;
</code></pre>
<p><strong>JS的构造方法</strong></p>
<p>首先展示一个简单的代码：<br>    <!DOCTYPE html><br>    <html><br>    <head><br>        <meta charset="utf-8"><br>        <title>study</title><br>        <script type = "text/javascript"><br>            function Person(name, age, gender)<br>            {<br>                this.name = name;<br>                this.age = age;<br>                this.gender = gender;<br>                alert("Hello!");<br>                this.changeName=changeName;<br>                function changeName(name)<br>                {<br>                    this.lastname=name;<br>                }//changeName() 函数 name 的值赋给 person 的 lastname 属性。<br>            }<br>            var Jogh = new Person("jogh", 12, "male");// 如果 new 了函数内的 this 会指向当前这个 person 并且就算函数内部不 return 也会返回一个对象。</p>
<pre><code>    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在编写js代码的时候需要添加如下语句来声明这是一个JS代码块。    </p>
<pre><code>&lt;script type = &quot;text/javascript&quot;&gt;
&lt;/script&gt;
</code></pre>
<p>上述代码块中，Person是一个带参数的构造方法，this是指代该构造方法生成的对象；构造方法与普通方法不同之处在于构造方法调用的时候前面有一个关键字new。<br>原型prototype（重点）</p>
<p>在我们所创建的每一个函数，解析器都会函数添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype，这个对象没有任何作用。当函数以构造函数调用，他所创建的对象中都会有一个隐含的属性，通过__proto__来访问该属性。原型对象相当于一个公共的区域，所有的同一类的实例都可以访问到这个原型对象。<br>    function MyClass()<br>    {}<br>    function Person()<br>    {}<br>    var per = new Person();<br>    MyClass.prototype == per.<strong>proto</strong>//true</p>
<p>程序中调试是测试，查找及减少bug(错误)的过程。</p>
<p>关键字let 和 const</p>
<p>ES6 可以使用 let 关键字来实现块级作用域。<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p>
<pre><code>&#123; 
    let x = 2;
&#125;
// 这里不能使用 x 变量
</code></pre>
<p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改：</p>
<pre><code>const PI = 3.141592653589793; PI = 3.14;      // 报错 PI = PI + 10;   // 报错
</code></pre>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 英文全称 JavaScript Object Notation；</p>
<p>JSON 是一种轻量级的数据交换格式；</p>
<p>JSON是独立的语言；</p>
<p>JSON 易于理解。</p>
<p>JSON 语法规则<br>数据为 键/值 对。<br>数据由逗号分隔。<br>大括号保存对象<br>方括号保存数组</p>
<h1 id="数组的基本操作-（Array）"><a href="#数组的基本操作-（Array）" class="headerlink" title="数组的基本操作 #（Array）"></a>数组的基本操作 #（Array）</h1><p>数组也是一个对象，不同的是普通的对象是使用字符串作为属性名，而数组是使用数字作为索引来操作元素。</p>
<p>数组长度没有限制，数组元素可以是数据类型。<br>数组创建：<br>    var arr = new Array();//使用构造函数创建数组，无参；<br>    var arr0 = new Array(10, 20, 30);//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素间用，隔开；<br>    var arr1 = new Array(10);//长度为10<br>    var arr2 = [];<br>    var arr3 = [1,2,3,4];</p>
<p>使用typeof检查一个数组时，会返回object。<br>    console.log(typeof arr)//返回object<br>    arr[0] = 10;//添加元素，索引是从0开始的整数。<br>    console.log(arr.length)//获取数组的长度</p>
<h3 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h3><pre><code>arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;);//向数组末尾添加一个或者多个元素，并返回数组新的长度
arr.unshift(&quot;牛魔王&quot;);//向数组的开头添加一个或者多个元素，并返回新的数组长度

arr.pop();//删除数组最后一个元素，并将被删除的元素返回
arr.shift();//删除数组的第一个元素，并将被删除的元素返回
</code></pre>
<p>#数组遍历：#<br>    for(var i = 0;i&lt;arr.length;i++)<br>    {<br>        console.log(arr[i]);<br>    }</p>
<h3 id="forEach-这个方法只支持IE8以上的浏览器"><a href="#forEach-这个方法只支持IE8以上的浏览器" class="headerlink" title="forEach(这个方法只支持IE8以上的浏览器)"></a>forEach(这个方法只支持IE8以上的浏览器)</h3><pre><code>arr.forEach(function(a)&#123;
    console.log(&quot;hello&quot;);
    console.log(a);
    &#125;);
</code></pre>
<p>//像这种函数，由我们创建但不由我们调用，回调函数,数组中有几个元素就会执行几次。每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个就是当前正在遍历的元素，第二个参数是当前正在遍历元素的索引，第三个参数是正在遍历的数组对象</p>
<h3 id="slice-splice"><a href="#slice-splice" class="headerlink" title="slice|splice"></a>slice|splice</h3><pre><code>var result = arr.slice(0, 2);//截取开始位置的索引，截取结束位置的索引，包含开始不包含结束索引。该方法不会改变元素数组，而是将截取到的元素封装到一个新的数组中；第二个参数可以省略不写，此时会截取从开始索引往后的所有元素；索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1倒数第一个。
var result = arr.splice(0, 2, &quot;牛魔王&quot;);//可以用于删除数组中的指定元素，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回。第一个表示开始位置的索引，第二个表示删除的数量，第三个及以后的元素：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。
</code></pre>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>var arr = [1,2,3,2,2,1,3,4,2,5];<br>for(var i = 0;i&lt;arr.length;i++)<br>{<br>    for(var j = i+1;j&lt;arr.length;j++)<br>    {<br>        if(arr[i] == arr[j])<br>        {<br>            arr.splice(j, 1);<br>            //当删除了当前j所在的元素以后，后面的元素会自动补位。元素的长度也会跟着改变。<br>            j–;<br>        }<br>    }<br>}</p>
<h3 id="concat-join-reverse-sort"><a href="#concat-join-reverse-sort" class="headerlink" title="concat|join|reverse|sort"></a>concat|join|reverse|sort</h3><pre><code>var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;];
var arr2 = [&quot;白骨精&quot;,&quot;蜘蛛精&quot;]
result = arr.concat(arr2,&quot;牛魔王&quot;);//该方法可以连接两个或者多个数组，并将新的数组返回，不会对原数组产生影响
result = arr.join(&quot;@-@&quot;);//该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串返回，在join()中可以指定字符串作为参数，该参数会成为数组中的元素连接符，默认为&quot;,&quot;。
arr.reverse();//该方法用来反转数组，修改原数组
arr.sort();//用来对数组中的元素进行排序，修改原数组，默认会按照Unicode编码进行排序，即使对于纯数字的数组，可能会得到错误结果。添加回调函数，指定排序规则，回调函数中定义两个形参，a在b前面：
arr.sort(funtion(a,b)&#123;
         if(a&gt;b)
            return 1;
        else 
            return 0;
            &#125;);
arr.sort(funtion(a,b)&#123;
         return a-b;
            &#125;);
Math.min(...arr);获取数组中的最小值。
</code></pre>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><pre><code>array.indexOf 此方法判断数组中是否存在某个值，如果存在返回数组元素的下标，否则返回-1
let arr = [&#39;something&#39;, &#39;anything&#39;, &#39;nothing&#39;, &#39;anything&#39;];let index = arr.indexOf(&#39;nothing&#39;);console.log(index) //结果是2
</code></pre>
<p>省略号</p>
<p>1、第一个叫做 展开运算符(spread operator)，作用是和字面意思一样，就是把东西展开。可以用在array和object上都行。</p>
<p>2、第二个，第三个叫做 剩余操作符(rest operator)，是解构的一种，意思就是把剩余的东西放到一个array里面赋值给它。一般只针对array的解构<br>求数组中的最大值、最小值</p>
<pre><code>Math.max(...arr);//Math.min(...arr);
Math.max.apply(null, arr);
Math.max.call(Math, arr[0], arr[1], arr[2], arr[3]);
Math.max(arr[0], arr[1], arr[2], arr[3])
</code></pre>
<p>Math.max()方法，支持传递多个参数，比如：Math.max(1,4,5,2,9)</p>
<p>但是它不支持直接传递一个数组作为参数，比如：Math.max(new Array(1,4,5,2,9))。<br>Function.apply()是JS的一个OOP特性，一般用来模拟继承和扩展this的用途，对于上面这段代码，可以这样去理解：</p>
<p>XXX.apply是一个调用函数的方法，其参数为：apply(Function, Args)，</p>
<p>Math.max.call可以调用任意个参数；<br>Function为要调用的方法，Args是参数列表，当Function为null时，默认为上文，即<br>    Math.max.apply(null, arr) </p>
<p>可认为是 apply(Math.max, arr)<br>然后，arr是一个参数列表，对于max方法，其参数是若干个数，即</p>
<pre><code>Math.max(a, b, c, d, ...)
</code></pre>
<p>当使用apply时，把所有参数加入到一个数组中，即<br>arr = [a, b, c, d, …]，代入到原式，</p>
<pre><code>Math.max.apply(null, [a, b, c, d, ...])
</code></pre>
<p>实际上等同于    </p>
<pre><code>Math.max(a, b, c, d, ...)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/jQuery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/jQuery/" class="post-title-link" itemprop="url">jQuery</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 15:49:10 / Modified: 15:52:51" itemprop="dateCreated datePublished" datetime="2022-01-04T15:49:10+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;test(runoob.com)&lt;/title&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
    &lt;/script&gt;
    &lt;script&gt;
        $(function()&#123;
            $(&quot;p&quot;).click(function()&#123;
                $(this).hide();
                        &#125;)&#125;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt;
    &lt;p&gt;继续点我!&lt;/p&gt;
    &lt;p&gt;接着点我!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/Redux/" class="post-title-link" itemprop="url">Redux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-04 15:25:55 / Modified: 19:52:51" itemprop="dateCreated datePublished" datetime="2022-01-04T15:25:55+08:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>构建react项目</p>
<p>  <code>npx create-react-app redux-demo</code></p>
</li>
<li><p>删除多余的文件<br>(留下index.css,index.js,App.js)</p>
</li>
<li><p>在pages目录下创建Home组件</p>
</li>
<li><p>编写一个简单的结构样式</p>
<p>  <code>&lt;button&gt;发送一个action&lt;/button&gt;</code></p>
</li>
<li><p>在App.js中引入这个组件</p>
</li>
<li><p>安装redux</p>
<p>  <code>yarn add redux</code></p>
<h2 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h2></li>
<li><p>在根目录下创建一个文件夹action</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建Action</p>
<p>  const senAction = ()=&gt;{…};</p>
</li>
<li><p>在action创建函数里面利用return，返回一个action对象，注意需要携带type属性</p>
<p>  const sendAction=()=&gt;{return{type:”send_action”, value:”发送了一个action”}}</p>
</li>
<li><p>把这个action创建函数进行导出</p>
<p>  module.exports = {sendAction}</p>
<h2 id="创建一个Reducer"><a href="#创建一个Reducer" class="headerlink" title="创建一个Reducer"></a>创建一个Reducer</h2></li>
<li><p>在根目录下创建一个reducer</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建reducer，注意reducer要接收两个参数</p>
<p>  const rootReducer = (state, action) =&gt;{…};</p>
</li>
<li><p>第一个参数是默认状态，我们可以定义一个初始化的state，然后进行赋值</p>
<p>  const initState = {value:”默认值”}<br>  const rootReducer = (state = initState, action)=&gt;{…};</p>
</li>
<li><p>在函数里面判断第二个参数action的type是否是我们发送的</p>
</li>
<li><p>如果是的话，我们可以通过return返回新的state</p>
</li>
<li><p>把reducer进行导出</p>
<h2 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h2></li>
<li><p>在根目录下创建一个文件夹store</p>
</li>
<li><p>在该目录下创建一个index.js文件，用来构建store，注意createStore函数里面第一个参数接收的是reducer</p>
<p>  import {createStore} from “redux”;<br>  const store = createStore{reducer};</p>
</li>
<li><p>我们需要导入刚刚创建的reducer，然后设置到函数里面去</p>
</li>
<li><p>createStore的返回值就是我们构建好的store，然后进行导出</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiling Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="font-end study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/React/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-03 20:15:35" itemprop="dateCreated datePublished" datetime="2022-01-03T20:15:35+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 15:46:24" itemprop="dateModified" datetime="2022-01-04T15:46:24+08:00">2022-01-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React-脚手架的使用"><a href="#React-脚手架的使用" class="headerlink" title="React 脚手架的使用"></a>React 脚手架的使用</h1><h2 id="使用React脚手架初始化项目"><a href="#使用React脚手架初始化项目" class="headerlink" title="使用React脚手架初始化项目"></a>使用React脚手架初始化项目</h2><pre><code>npx create-react-app my-app//使用React脚手架初始化项目
npm start//启动项目
</code></pre>
<h2 id="创建元素，渲染元素"><a href="#创建元素，渲染元素" class="headerlink" title="创建元素，渲染元素"></a>创建元素，渲染元素</h2><pre><code>import React from &#39;react&#39;
import ReactDom from &#39;react-dom&#39;
const name = &quot;Jack&quot;
const age = 19
//创建react元素
const title = (
    &lt;h1 className=&quot;title&quot;&gt;
    hello React, &#123;name&#125;, 年龄：&#123;age&#125;
    &lt;/h1&gt;
)
//渲染react元素
ReactDom.render(title, document.getElementById(&#39;root&#39;))
</code></pre>
<h3 id="创建元素："><a href="#创建元素：" class="headerlink" title="创建元素："></a>创建元素：</h3><pre><code>const title = React.createElement(&quot;h1&quot;, null, &quot;Hello React&quot;);
const title = (
    &lt;h1 className=&quot;title&quot;&gt;
    hello React!!!
    &lt;/h1&gt;
)//JSx
</code></pre>
<h4 id="React组件的两种创建方式："><a href="#React组件的两种创建方式：" class="headerlink" title="React组件的两种创建方式："></a>React组件的两种创建方式：</h4><ol>
<li><p>使用函数创建组件</p>
<p> 函数组件：使用JS的函数（或箭头函数）创建组件</p>
<p> 约定1：函数名称必须大写</p>
<p> 约定2：函数组件必须有返回值，表示该组件的结构</p>
<p> 如果返回值是null，表示不渲染任何元素</p>
<p> 渲染函数组件：用函数名作为组件标签名</p>
<p> 组件标签名既可以是单标签，也可以是双标签。</p>
<pre><code> function Hello()&#123;
 return (&lt;div&gt;
 这是我的第一个函数组件
 &lt;/div&gt;)
 &#125;
 const Hello1=()=&gt;&lt;div&gt;这是我的第一个函数组件&lt;/div&gt;
 ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#39;root&#39;));
</code></pre>
</li>
<li><p>使用类创建组件</p>
<p> 类组件：使用ES6的class创建的组件</p>
<p> 约定1：类名称必须以大写字母开头</p>
<p> 约定2：类组件应该继承React.Componet父类，从而可以使用父类中提供的属性与方法</p>
<p> 约定3：类组件必须提供render()方法。</p>
<p> 约定4：render()方法必须有返回值，表示该组件的结构</p>
<pre><code> class Hello extends React.Component&#123;
 render()&#123;
     return (&lt;div&gt;
     这是我的第一个div
     &lt;/div&gt;)
     &#125;
 &#125;
</code></pre>
</li>
<li><p>抽离为独立的JS文件</p>
<p> 1.创建Hello.js</p>
<p> 2.在Hello.js中创建组件并导出该组件</p>
<p> 3.在index.js中导入Hello组件</p>
<h1 id="React事件处理"><a href="#React事件处理" class="headerlink" title="React事件处理"></a>React事件处理</h1><h2 id="1-事件绑定"><a href="#1-事件绑定" class="headerlink" title="1.事件绑定"></a>1.事件绑定</h2></li>
</ol>
<p>语法：on + 事件名称 = {事件处理程序}，比如：    </p>
<pre><code>onClick=&#123;()=&gt;&#123;&#125;&#125;
</code></pre>
<p>驼峰命名法：比如：onMouseEnter、onFocus。</p>
<pre><code>class App extends React.Component&#123;
handleClick()&#123;
console.log(&quot;单击事件触发了&quot;);&#125;
render()&#123;
return (&lt;button onClick = &#123;this.handleClick&#125;&gt;点击&lt;/button&gt;)
                                                            &#125;
&#125;
function App()&#123;
function handleClick()&#123;
console.log(&quot;单击事件触发了&quot;);&#125;
return (&lt;button onClick = &#123;handleClick&#125;&gt;点击&lt;/button&gt;)
&#125;
</code></pre>
<h2 id="2-事件对象"><a href="#2-事件对象" class="headerlink" title="2.事件对象"></a>2.事件对象</h2><p>可以通过事件处理程序的参数获取事件对象</p>
<p>React中的事件对象叫做：合成事件（对象）<br>    function handleClick(e){<br>        e.preventDefault()<br>        console.log(‘事件对象’, e)<br>    }<br>    <a onClick={handleClick}>点我不会跳转页面</a></p>
<p>有状态组件与无状态组件</p>
<p>函数组件又叫做无状态组件，类组件又叫做有状态组件。</p>
<p>状态即数据，函数组件没有自己的状态，只负责数据展示（静）</p>
<p>类组件有自己的状态，负责更新UI， 让页面动起来.<br>组件中的state与setState<br>state的基本使用</p>
<p>状态就是数据，是组件内部私有数据，只能在组件内部使用</p>
<p>state的值是对象，表示一个组件中可以有多个数据    </p>
<pre><code>constructor() &#123;
    super();
    this.state = &#123;
    count:0
    &#125;
&#125;
state = &#123;count:0&#125;//两种初始化状态的方法
&#123;this.state.count&#125;//获取状态

import React from &#39;react&#39;
class Hello extends React.Component&#123;
constructor() &#123;
    super();
    this.state = &#123;
    count:0,
    test:&#39;a&#39;
    &#125;
&#125;
// state = &#123;count:0&#125;
handleClick(e)&#123;
    e.preventDefault()
    console.log(&quot;a标签的单击事件被触发了&quot;)
&#125;

render() &#123;
    return (
    &lt;div&gt;
        &lt;h1&gt;
        计数器：&#123;this.state.count&#125;
        &lt;/h1&gt;
        &lt;button onClick=&#123;()=&gt;&#123;
            this.setState(&#123;count:this.state.count+1&#125;)
        &#125;&#125;&gt;
        +1
        &lt;/button&gt;
    &lt;/div&gt;);
    &#125;
&#125;
export default Hello
</code></pre>
<p>setState()修改状态</p>
<p>状态时可变的</p>
<p>语法：this.setState({要修改的数据})</p>
<p>注意：不要直接修改state中的值，这是错误的。</p>
<p>setState()作用：1.修改state2.更新UI</p>
<p>思想：数据驱动视图</p>
<pre><code>//正确
this.setState(&#123;
    count:this.state.count+1
&#125;)
//错误
this.state.count += 1
</code></pre>
<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><h2 id="1-受控组件"><a href="#1-受控组件" class="headerlink" title="1.受控组件"></a>1.受控组件</h2><p>HTML中的表单元素是可输入的，也就是有自己的可变状态</p>
<p>而，react中的可变状态通常保存在state中，并且只能通过setState()方法来修改。</p>
<p>React将state与表单元素值value绑定在一起，由state的值来控制表单元素的值。</p>
<p>受控组件：其值收到React控制的表单元素</p>
<p>步骤：</p>
<p>在state中添加一个状态，作为表单元素的value值（控制表单元素值的来源）<br>给表单元素绑定change事件，将表单元素的值设置为state的值（控制表单元素值的变化）</p>
<pre><code>state = &#123;txt:&#39;&#39;&#125;
&lt;input type = &quot;text&quot; value = &#123;this.state.txt&#125;
    onChange = &#123;e=&gt;this.setState(&#123;txt:e.target.value&#125;)&#125;
    /&gt;
</code></pre>
<p>多表单元素优化：</p>
<p>给表单元素添加name属性，名称与state相同<br>根据表单元素类型获取相应值<br>在change事件处理程序中通过[name]来修改对应的state    </p>
<pre><code>&lt;input type = &quot;text&quot; name = &quot;txt&quot; value = &#123;this.state.txt&#125; onChange = &#123;this.handleForm&#125;/&gt;
//根据表单元素类型获取值
const value = target.type === &#39;checkbox&#39;?target.checked:target.value
//根据name设置对应的state
this.setState(&#123;
[name]:value
&#125;)
</code></pre>
<h2 id="2-非受控组件"><a href="#2-非受控组件" class="headerlink" title="2.非受控组件"></a>2.非受控组件</h2><p>调用React.createRef()方法创建一个ref对象将创建好的Ref对象添加到文本框中<br>通过ref对象获取到文本框中的值</p>
<pre><code>constructor()&#123;
    super()
    this.txtRef = React.createRef()
&#125;
&lt;input type = &quot;text&quot; ref = &#123;this.txtRef&#125;/&gt;
Console.log(this.txtRef.current.value)
</code></pre>
<p>组件的props</p>
<p>组件是封闭的，要接收外部数据应该通过props来实现</p>
<p>props的作用：接受传递给组件的数据</p>
<p>传递数据：给组件标签添加属性</p>
<p>接收数据：函数组件通过参数props接收数据，类组件通过this.props接收数据</p>
<pre><code>&lt;Hello name = &quot;jack&quot; age = &#123;19&#125;/&gt;//传递数据
function Hello (props)&#123;
    //props是一个对象
    console.log(props)
    return (&lt;div&gt;接收到的数据：&#123;props.name&#125;&lt;/div&gt;)
&#125;
class Hello extends React.Component&#123;
    render()&#123;
        return (&lt;div&gt;
            接收到的数据：&#123;this.props.age&#125;&lt;/div&gt;)
    &#125;
&#125;
</code></pre>
<h1 id="组件通讯的三种方式"><a href="#组件通讯的三种方式" class="headerlink" title="组件通讯的三种方式"></a>组件通讯的三种方式</h1><h2 id="1-父组件传递数据给子组件"><a href="#1-父组件传递数据给子组件" class="headerlink" title="1.父组件传递数据给子组件"></a>1.父组件传递数据给子组件</h2><p>父组件提供要传递的state数据</p>
<p>给子组件标签添加属性，值为state中的数据</p>
<p>子组件中通过props接收负组件中传递的数据<br>    class Parent extends React.Component{<br>        state = {lastName:’王’}//第一步<br>        render(){<br>            return (<div><br>                传递给子组件：&lt;Child name = {this.state.lastName}//第二步<br>            </div>)<br>        }<br>    }</p>
<pre><code>function Child(props)&#123;
        return &lt;div&gt;子组件接收到的数据：&#123;props.lastName&#125;&lt;/div&gt;//第三步
&#125;
</code></pre>
<h2 id="2-子组件传递数据给父组件"><a href="#2-子组件传递数据给父组件" class="headerlink" title="2.子组件传递数据给父组件"></a>2.子组件传递数据给父组件</h2><p>思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数</p>
<p>父组件中提供一个回调函数（用于接收数据）<br>将该函数作为属性的值传递给子组件<br>子组件通过props调用回调函数<br>将子组件的数据作为参数传递给回调函数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weiling Wu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weiling Wu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
